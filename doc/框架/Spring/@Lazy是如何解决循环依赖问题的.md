首先，让我们回顾一下 `@Lazy` 注解的两个特性
1. **延迟创建**。我们知道，非懒加载的单例 bean 在 Soring 容器启动时，就会完成创建;而使用了 `@Lazy` 注解修饰的懒加载的单例bean，只有当首次被使用的时候才会去创建。这类 bean 一般被如下注解组合修饰:@Component+ `@Lazy`;@Bean + `@Lazy`:@Configuration + `@Lazy` 等。
2. **延迟注入**。当 `@Lazy` 注解和 @Autowired 注解搭配使用，或者应用在构造方法之上，或者应用在构造方法的属性之上时，Spring都会先给该属性注入一个代理对象，只有在首次访问该属性时，Spring 才会执行该代理对象的逻辑，给该属性注入一个真正的bean 对象。

`@Lazy` 注解可以用在解决构造器注入的循环依赖问题上。那么它是怎么解决的呢？
我们还是拿 UserService 和 OrderService 为例,我们假设 UserService 先被创建，首先在调用构造方法完成实例化的过程中，因为构造方法上使用了 `@Lazy` 注解，所以 Spring 会给参数 orderService 注入一个代理对象，这样 UserService 就能够完成实例化和接下来的初始化的步骤，最终创建成功并放入单例池;因为 UserService 已经被 Spring 放入了单例池，所以，OrderService 也是可以顺利完成创建的。这样，也就解决了构造器注入的循环依赖的问题了。

但是，过度使用 `@Lazy` 注解可能会导致应用程序的行为难以预测和跟踪，特别是在涉及多个依赖的情况下。而且，循环依赖问题通常都是代码设计上的问题，我们还是应该通过代码重构的方式在根源上避免它!