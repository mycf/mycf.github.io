在 Java 中，有两种使用 `final` 关键字声明的变量：最终变量（final variable）和最终有效变量（effectively final variable）。

1. 最终变量（final variable）：使用 `final` 关键字声明的变量是一种常量，其值在初始化后不能被修改。一旦给最终变量赋值，就无法再改变它的值。例如：

```java
final int x = 10;
```

在上述示例中，变量 `x` 被声明为最终变量，其值为 10，不能再被修改。

2. 最终有效变量（effectively final variable）：最终有效变量是指在代码中虽然没有使用 `final` 关键字声明，但在其后续的使用中没有被修改的局部变量。最终有效变量可以被视为一种类似于最终变量的约束，即一旦初始化后就不能再被修改。例如：

```java
int y = 20;
y = y + 5; // 修改 y 的值
```

在上述示例中，变量 `y` 在初始化后被修改了，因此不符合最终有效变量的条件。

```java
int z = 30;
// z 没有被修改
```

而在这个示例中，变量 `z` 在初始化后没有被修改，因此可以被视为最终有效变量。

最终有效变量的主要用途是在 Java 8 引入的 Lambda 表达式和匿名内部类中。这些语法结构要求在访问局部变量时，被访问的变量必须是最终有效变量或最终变量。

需要注意的是，在 Java 8 之前的版本中，匿名内部类中访问局部变量时，这些变量必须显式声明为最终变量（使用 `final` 关键字）。从 Java 8 开始，可以省略 `final` 关键字，但要求变量是最终有效变量,*这使得它们由于不变性而成为线程安全的*。


[Java SE8语言规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12)

4.12.4. final变量

变量可以声明为final。final变量只能被赋值一次。如果一个final变量在赋值之前没有被明确赋值，则在赋值时会出现编译时错误（§16（明确赋值））。
一旦final变量被赋值，它就始终包含相同的值。如果一个final变量持有一个对象的引用，则对象的状态可以通过对该对象的操作来改变，但变量始终指向同一对象。这也适用于数组，因为数组是对象；如果一个final变量持有对数组的引用，则可以通过对数组的操作来更改数组的组件，但变量始终指向同一数组。
空final是一个声明缺少初始化器的final变量。
常量变量是使用常量表达式（§15.28）初始化的原始类型或类型String的final变量。变量是否为常量变量可能会涉及到类初始化（§12.4.1）、二进制兼容性（§13.1、§13.4.9）和明确赋值（§16（明确赋值））。
有三种变量被隐式声明为final：接口字段（§9.3）、try-with-resources语句的资源局部变量（§14.20.3）和multi-catch子句的异常参数（§14.20）。单个catch子句的异常参数永远不会被隐式声明为final，但可能会被有效地声明为final。
示例4.12.4-1。最终变量
声明一个变量为final可以作为有用的文档，说明其值不会发生变化，并有助于避免编程错误。在这个程序中：
```java
class Point {
  int x, y;
  int useCount;
  Point(int x, int y) { this.x = x; this.y = y; }
  static final Point origin = new Point(0, 0);
}
```
类Point声明了一个final类变量origin。origin变量持有一个引用，该引用是类Point的一个实例，其坐标为（0,0）。变量Point.origin的值永远不会改变，因此它始终指向同一个Point对象，即由其初始化器创建的对象。然而，对这个Point对象的操作可能会改变它的状态——例如，修改它的useCount甚至是误导性地修改它的x或y坐标。

某些未声明为final的变量被认为是有效的final：
如果局部变量的声明符具有初始化程序（§14.4.2），则当以下所有条件都为true时，它是有效的final：
它没有被声明为final。

它从未出现在赋值表达式（§15.26）的左侧。（请注意，包含初始化程序的局部变量声明符不是赋值表达式。）

它从未作为前缀或后缀递增或递减运算符（§15.14、§15.15）的操作数出现。

如果局部变量的声明符缺少初始化程序，则当以下所有条件都为true时，它是有效的final：
它没有被声明为final。

每当它在赋值表达式的左侧出现时，它都是明确未分配且在分配之前不明确分配；也就是说，在赋值表达式的右侧之后，它肯定未分配且不确定分配（§16（明确分配））。

它从未作为前缀或后缀递增或递减运算符的操作数出现。

对于确定是否有效地final，方法、构造函数、lambda或异常参数（§8.4.1、§8.8.1、§9.4、§15.27.1、§14.20）被视为具有初始化程序的局部变量。

如果一个变量是有效的final，在其声明中添加final修饰符不会引入任何编译时错误。相反，如果在有效程序中声明了一个局部变量或参数，则在删除final修饰符后，该局部变量或参数将成为有效的final。
