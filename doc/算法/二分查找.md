编写二分查找代码：

1. 前提: 有已排序数组 A(假设已经做好)
2. 定义左边界 L、右边界 R，确定搜索范围，循环执行二分查找(3、4两步)
3. 获取中间索引 M = Floor((L+R) /2)
4. 中间索引的值 A[M] 与待搜索的值 T 进行比较
   - A[M] == T 表示找到，返回中间索引
   - A[M]>T，中间值右侧的其它元素都大于无需比较，中间索引左边去找，M - 1 设置为右边界，重新查找
   - A[M]< T，中间值左侧的其它元素都小于无需比较，中间索引右边去找， M +1 设置为左边界，重新查找
5. 当L> R 时，表示没有找到，应结束循环




奇数二分取中间值
偶数二分取中间靠左

```java
public class AppTest2 {
    public static void main(String[] args) {
        int[] a = {1, 3, 4, 7, 8, 9, 10, 13, 41};
        int idx = binarySearch(a, 7);
        System.out.println(idx);
    }

    public static int binarySearch(int[] a, int t) {
        int l = 0, r = a.length - 1, m;
        while (l <= r) {
            m = (l + r) / 2;
            if (a[m] == t) {
                return l;
            } else if (a[m] < t) {
                l = m - 1;
            } else {
                r = m + 1;
            }
        }
        return -1;

    }
}

```

上面代码的问题：

就是在计算这个中间索引`m`的时候, 我们用的是`(l+r)/2`这个公式, 但是当`l`和`r`它们的取值, 如果都特别大的话, 它俩相加就有可能超过整数 能存储的最大值, 从而造成了一个整数溢出问题, 那所以接下来我们就看一下, 在获取中间索引的时候, 怎么去避免这种整数溢出的现象

那我们先来看一下这个现象演示吧, 那这里假设我的待查找的数组，它的长度已经是整数的最大值了也就是`Integer.MAX_VALUE`，它的取值是20亿多啊, 那这个时候我们左边界刚开始是零对吧, 那右边界呢就是它的长度减一对吧, 也就是这个21-1啊, 那第一次计算其实还没有问题啊, 虽然这个r已经非常大了, 但l呢左边界很小啊, 左边界是零, 所以他俩加起来再除以二, 并不会超过咱们整数的存储范围, 所以第一次计算出来, 这个中间值呢是没有问题的, 好可以看到大约就是10亿多是吧, 但是我们如果查找的这个值啊, 在中间值的右侧让大家思考一下, 在中间值的右侧, 在右侧的话, 那意味着什么, 你要修改左边界, 对不对, 左边界呢应该等于m加一啊, 等于中间索引加一, 那m已经是11了, 再加一当然也是11多一点, l就是10亿多啊, 10亿多, 再加上r的21, 那整数能存下吗, 存不下来啊, 因为它最大也就是20亿, 你再加个10亿, 那已经超过它的存储范围了, 所以就会产生一个溢出, 可以咱们试一下啊, 那么按现在的l跟r啊, 再去套用公式去计算中间值, 你就会发现溢出所导致的啊, 就是它会变成一个负数啊, 这也是这个溢出的现象。



假如`l = 0, r  = Integer.MAX_VALUE`，那么`m = Integer.MAX_VALUE/2 `，下一次遍历就会可能出现如下情况：

```java
System.out.println(Integer.MAX_VALUE);
System.out.println((Integer.MAX_VALUE + Integer.MAX_VALUE/2)/2);
```
输出结果如下

```sh
2147483647
-536870913
```

要怎么解决呢，`(l+r)/2`改为`l + (r-l)/2`，这样就不会出现整数溢出的情况了。

换算公式如下

```java
(l+r)/2 = l/2 + r/2 = l - l/2 + r/2 = l + (r-l)/2
```

为什么两个正整数相加超过了范围, 变成负数, 这个现象不是特别了解, 那我这给大家也演示一下啊, 当然我演示我就不用整数去演示了啊, 因为整数那个太大了, 我用`byte`来演示，`byte` 它的最大值是127 那127-1, 那是不是126啊, 咱们看一下啊, 这是126, 用二进制表示, 就是1111110啊, 这么一个数字符号位是零, 表示它是个正整数, 那还有一个呢就是啊126÷2, 是不是63呀, 还是63, 63呢是用二进制表示, 是111111啊, 也是个正整数, 符号位是三零, 但是呢同学们同学们考虑一下, 我现在的63+126会发生什么, 咱们就用二进制的加法来加一下啊, 二进制加法就是逢二进一, 那大家看啊, 先从最低位开始加嘛, 哎0+1是一对不对, 然后1+1是零啊, 进位啊, 进一位啊, 进一位, 然后这边1+1是一进一位, 然后再1+1进一位, 1+1进一位, 1+1进一位好, 这边1+1进一位等于零, 但是注意他是不是进了一位啊, 进了一位他就会把符号位改变成一啊, 结果就导致我们刚才的两个正数相加, 变成了负的67啊, 本来应该是我们来算一下啊, 本来是126+63嘛, 126+63, 应该是一个正数的189啊, 但是我们发现啊, 他如果发生这种溢出现象, 最终得到的是一个负的67啊, 这也是为什么溢出会导致问题啊, 那怎么去解决这个问题呢, 啊其实呃也简单, 这里我介绍两种做法, 那第一种做法呢, 我们就是采用一些数学上的变化, 比如说我们刚才这个公式是l加上r除以二, 那我们的问题是l r都特别大的时候, 它就有益处, 那怎么办呢, 大家看我下面这个等价的变化啊, 刚才这个公式呢我们可以这样看啊, 它其实是l的1/2, 加上r的1/2, 是这样吧, 那他又可以变换成l减去l的1/2, 然后再加上r的1/2, 我们把后面这两个组合在一起, 加个括号, 这个变成负数, 是不是就变成了什么r减去l除以二, 好最后就变成了l加上括号, r减去l括号除以二啊, 这是小学生都能算出来的, 对不对啊, 都能变换的一个公式啊, 那所以我们把这个公式套进去, 为什么这个公式就能解决我们溢出问题呢, 啊大家注意l和r虽然很大, 但是他俩一减, 是不是就变成一个比较小的数字了啊, 他再除以二啊, 它自然就不会超过我们整数的那个, 最大值的范围啊, 所以我们把这个公式套进去, 这个套进去啊, 下面这个也套进去, 啊你会发现, 那最终我们这个第二次计算的中间索引, 它就不会溢出了, 而是应该是1000000000+2000000000÷2啊, 大约是16亿多啊, 16亿多啊, 这样就解决了我们这个整数溢出问题啊, 好这是第一种解决方法



```java
m = (l + r) >>> 2
```



先说一个小问题啊, 刚才我在做这个公式推导的时候, 中间这个位置我加了括号以后, 忘了把外面这个减号变过来了啊, 应该是加号啊, 这个请大家注意一下, 好, 咱们把刚才的代码先备份一下, 啊然后啊这个代码咱们复制一份啊, 我们来介绍方法二, 其实啊方法二它更加高效一些, 它的具体做法呢是用无符号右移运算代替掉, 除法啊, 这个代码咱就不要了, 是l加上r也就是左边界加右边界, 本来不是要除二吗, 对吧, 哎我们把它换成一个无符号的右移运算啊, 右移一位, 它不光是能解决我们的这个溢出问题, 而且呢效率上也要比触发高啊, 因为cpu呢在对处理这个移位运算, 所需要消耗的时钟周期, 比你进行这个除法运算所需要的时钟周期更少, 好, 下面呢我们计算这个中间索引的代码, 也改变一下啊, 改完了之后呢, 咱们先验证一下, 看看这种做法是不是能达到啊, 不发生溢出的这种效果对吧, 那我们把之前的这个结果先记录一下, 然后重新运算, 看看两次是不是一致啊, 啊先看结论, 第一次啊计算出来这个中间索引是10亿多, 这个数对吧, 第二次呢计算出来是16亿这个数啊, 两次结果都一样啊, 说明没有问题, 那有同学说了, 那既然l跟r都比较大, 那第第二次的时候这个l r都比较大, 他为什么明明是溢出了, 我们用这个移位又能避免它的益处啊, 这个咱们就来分析分析啊, 我还是用之前这个bt的例子, 还记得吧, 之前呢我说过126和63, 如果我们把它限制在这个bt范围内做加法, 由于呢他把符号位改变成了一啊, 导致它变成了一个负数, 对不对, 那我们还是以这个例子来说啊, 啊明明他俩应该啊加起来是189, 结果变成了负的67, 对不对, 但是呢咱们换一种思路啊, 我们是把它当成了啊, 把它当成了bt, 那他就把最高位当成了符号位, 但是大家想, 如果呢我把它就当成一个更大的一个数字, 比如说是这种啊, 这里的计算器里的word就相当于咱们的shot, 是一个两个字节的数字, 那它的范围能不能存下啊, 这个189呢, 当然可以对吧, 那咱们一位一位给他挪过去啊, 看一下, 11111, 后面还有个一, 是不是189, 所以你如果把它当成一个更大范围的这个, 数据类型来考虑的话, 他这个信息并没有丢失啊, 还是189, 只是由于呢我们之前的这个问题, 就是由于他错误的把最高位的这个一, 当成了符号位, 把它识别成了负的67, 但是大家想啊, 那如果我把它整体右移一位的话, 整体右移, 那这个符号位是不是就恢复到了他正常的这个, 非符号的这些范围之内啊, 啊它就会又被可以正确的识别了, 所以它其实还是那个189, 当他右移之后, 他就不把最高位当成符号位, 自然也没有之前的问题了, 好那咱们来做一个右移运算啊, 那右移怎么移呢, 大家看啊, 那右移那就是把一移到这边了对吧, 好把这个零移到这这里, 四个一都平移过来, 这个零移过来, 当然最后这个e就移移走就没有了对吧, 那就变成了这样子啊, 你看着斜线来这, 右移吗, 上面是结果二, 下面这是原始的值, 这个一一到这对吧, 这个零一到这这四个一一次平移, 最后这个零平移过去啊, 当然这个e就移没了, 对吧啊, 移没了啊, 他就是达到了这么一个效果啊, 所以189右移一位, 他就得到了我们正确的啊, 这个94的结果, 虽然我们如果是这种bt, 他虽然刚开始把它最高位当错误的, 当成了符号位, 但是右移之后它就会恢复正常啊, 所以这是呃这种无符号右移, 能解决我们整数溢出的这个问题, 它的一个原因啊, 而且我们推荐这种做法, 因为它的效率我们前面也说了, 要比除法的效率要高啊, 啊那是不是最终是正确的, 94呢, 我们可以验证一下啊, 189, 你去如果用除二的话, 跟这个移位, 你会发现最终的效果是一样的, 是不是都是94啊, 啊当然请大家注意啊, 这个移位运算有很多这个课程上都会说啊, 他是完全等价于除法, 这个不是百分之百正确, 因为它只对正数运算, 它是等价于除二的操作, 如果你前面是个负, 本身就是个负数啊, 那么它并不能去等价于这个初二啊, 这个请大家注意好了, 关于我们这个二分查找的两种, 解决整数溢出的问题, 我们就分析到这儿

