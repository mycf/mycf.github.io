import{_ as r,c as t,o as i,ag as s,j as e}from"./chunks/framework.Bw-5EFTY.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"设计模式/创建型模式.md","filePath":"设计模式/创建型模式.md"}'),n={name:"设计模式/创建型模式.md"};function c(d,a,o,l,h,m){return i(),t("div",null,a[0]||(a[0]=[s('<p>创建型设计模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。</p><h2 id="抽象工厂模式" tabindex="-1">抽象工厂模式 <a class="header-anchor" href="#抽象工厂模式" aria-label="Permalink to &quot;抽象工厂模式&quot;">​</a></h2><p>Abstract Factory（抽象工厂）——对象创建型模式</p><p>提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。</p><h2 id="建造者模式" tabindex="-1">建造者模式 <a class="header-anchor" href="#建造者模式" aria-label="Permalink to &quot;建造者模式&quot;">​</a></h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h2 id="工厂方法模式" tabindex="-1">工厂方法模式 <a class="header-anchor" href="#工厂方法模式" aria-label="Permalink to &quot;工厂方法模式&quot;">​</a></h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p><h2 id="原型模式" tabindex="-1">原型模式 <a class="header-anchor" href="#原型模式" aria-label="Permalink to &quot;原型模式&quot;">​</a></h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h2 id="my-anchor" tabindex="-1">单例模式 <a class="header-anchor" href="#my-anchor" aria-label="Permalink to &quot;单例模式 {#my-anchor}&quot;">​</a></h2><p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>',12),e("figure",{class:"vpd-diagram vpd-diagram--excalidraw",onclick:`
        const figure = this;
        const isFullscreen = figure.classList.contains('vpd-diagram--fullscreen');
        
        document.querySelectorAll('.vpd-diagram').forEach(diagram => {
          diagram.classList.remove('vpd-diagram--fullscreen');
        });

        if (!isFullscreen) {
          figure.classList.add('vpd-diagram--fullscreen');
        }
      `},[e("img",{src:"/diagrams/excalidraw-85b0980477cfe40d74efb95e56274dce.svg",alt:"excalidraw Diagram",class:"vpd-diagram-image"})],-1)]))}const _=r(n,[["render",c]]);export{u as __pageData,_ as default};
