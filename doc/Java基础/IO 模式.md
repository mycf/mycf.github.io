Unix中的I/O模型是指在进行输入和输出操作时，操作系统与应用程序之间的交互方式。以下是常见的Unix I/O模型：

1. 阻塞式I/O（Blocking I/O）：在阻塞式I/O模型中，当应用程序发起I/O操作后，它会被阻塞（即暂停执行），直到操作完成。这意味着应用程序在等待I/O操作完成期间无法执行其他任务。

2. 非阻塞式I/O（Non-blocking I/O）：非阻塞式I/O模型允许应用程序在发起I/O操作后继续执行其他任务，而不会被阻塞。应用程序会立即返回，并通过轮询（polling）方式检查I/O操作是否完成。如果操作尚未完成，应用程序可以继续执行其他任务。

3. I/O复用（I/O Multiplexing）：I/O复用模型使用操作系统提供的select()、poll()或epoll()等函数，允许应用程序同时监听多个I/O事件。当有一个或多个I/O事件就绪时，应用程序可以进行相应的读取或写入操作。这样可以避免阻塞，提高并发性能。

4. 信号驱动式I/O（Signal-driven I/O）：信号驱动式I/O模型使用操作系统的信号机制来通知应用程序I/O操作的完成。应用程序首先通过指定信号处理函数来注册对特定信号的处理。当I/O操作完成时，操作系统发送一个信号给应用程序，应用程序在信号处理函数中进行相应的处理。

5. 异步I/O（Asynchronous I/O）：异步I/O模型允许应用程序发起I/O操作后立即返回，并通过回调函数或事件通知机制来处理操作的完成。应用程序不需要主动轮询或阻塞等待操作完成。操作系统在操作完成后会通知应用程序执行相应的回调函数。

这些I/O模型提供了不同的方式来处理输入和输出操作，并根据应用程序的需求和性能要求选择合适的模型。每种模型都有其优缺点，理解它们的工作原理和适用场景有助于设计高效的I/O操作和实现高性能的应用程序。





Selector类在Java NIO中提供了一组方法，用于管理和操作选择器及其关联的通道。以下是Selector类的一些主要方法及其作用：

1. open()：静态方法，用于创建一个新的Selector对象。

2. close()：关闭选择器。关闭选择器会释放与选择器关联的资源。

3. isOpen()：检查选择器是否处于打开状态。

4. select()：阻塞方法，用于等待至少一个通道准备好进行I/O操作。当有一个或多个通道准备好时，此方法返回准备就绪的通道数量。

5. select(long timeout)：指定超时时间的select方法。在超时时间内等待通道就绪，如果超时时间到达仍没有通道就绪，返回0。

6. selectNow()：非阻塞方法，立即返回准备就绪的通道数量，如果没有通道就绪则返回0。

7. selectedKeys()：获取选择器当前已选择的键集合。通过遍历这个键集合，可以获取已准备就绪的通道。

8. keys()：获取选择器当前注册的所有键集合。这个集合包含了所有已注册的通道的键。

9. wakeup()：唤醒阻塞在select()方法上的选择器。如果在调用select()方法时选择器处于阻塞状态，可以通过调用wakeup()方法来立即唤醒选择器，使其返回。

10. selector()：获取与选择器关联的底层Selector对象。

11. register(SelectableChannel channel, int ops)：将通道注册到选择器上，并指定感兴趣的事件类型。ops参数是一个位掩码，可以使用SelectionKey类中的常量来指定事件类型，如SelectionKey.OP_READ、SelectionKey.OP_WRITE等。

12. isValid()：检查选择器是否仍然有效。如果选择器关闭了或者与其关联的底层Selector对象无效，将返回false。

这些方法提供了选择器的基本操作和管理功能，包括创建选择器、关闭选择器、注册通道、等待就绪通道、获取已选择和已注册的键集合等。通过这些方法，可以实现非阻塞I/O的多路复用，以及管理和操作选择器及其关联的通道。



Buffer类具有几个主要属性，这些属性用于描述和管理缓冲区的状态和内容。下面详细介绍Buffer类的主要属性及其作用：

1. 容量（Capacity）：容量是指缓冲区的最大存储能力，即可以存储的数据元素数量。通过capacity()方法可以获取缓冲区的容量大小。容量在创建缓冲区时就确定，并且在整个生命周期中保持不变。

2. 位置（Position）：位置表示下一个要读取或写入的数据元素的索引。初始位置为0，通过position()方法可以获取当前位置的索引，通过position(newPosition)方法可以设置当前位置的索引。在写入数据时，位置会自动递增；在读取数据时，位置也会自动递增。

3. 限制（Limit）：限制表示缓冲区中有效数据的末尾索引，即限制位置之前的数据是有效数据。初始限制位置与容量相同，通过limit()方法可以获取当前限制位置的索引，通过limit(newLimit)方法可以设置限制位置的索引。在写入数据时，限制位置可以手动设置，用于限制写入的数据范围；在读取数据时，限制位置会自动设置为当前位置，用于限制读取的数据范围。

4. 标记（Mark）：标记是一个临时的索引，用于记录某个特定位置。通过mark()方法可以在当前位置设置标记，通过reset()方法可以将位置重置为标记的位置。标记不是必需的，可以根据需要进行设置和使用。

这些属性在Buffer类中相互协作，用于描述和管理缓冲区的状态。通过控制位置、限制和容量，可以有效地读取和写入数据，管理数据的范围和数量。标记属性则提供了一种临时记录位置的方式，方便后续操作时的位置重置。

需要注意的是，位置和限制的关系应满足以下条件：0 <= position <= limit <= capacity。这保证了位置不会超过限制，限制不会超过容量，从而有效地控制数据的读写范围。



Buffer类是Java NIO库中用于高效处理数据的缓冲区，提供了一系列方法用于读取和写入数据、操作缓冲区以及管理数据操作状态。下面详细介绍Buffer类的主要方法及其作用：

1. 写入数据的方法：
  - put(data)：向缓冲区写入数据，可以一次写入一个数据元素或一组数据元素。
  - put(index, data)：在指定位置写入数据元素。
  - put(buffer)：将另一个Buffer中的数据写入当前缓冲区。
2. 读取数据的方法：
- get()：从缓冲区读取一个数据元素。
- get(index)：从指定位置读取数据元素。
- get(array)：将缓冲区中的数据读取到指定数组中。
- get(array, offset, length)：将缓冲区中的数据读取到指定数组的指定位置。
3. 检索和设置缓冲区的状态方法：
- position()：获取当前位置，即下一个数据元素的索引。
- position(newPosition)：设置当前位置的索引。
- limit()：获取限制位置，即缓冲区中有效数据的末尾索引。
- limit(newLimit)：设置限制位置的索引。
- capacity()：获取缓冲区的容量大小。
- flip()：切换读写模式，将限制位置设置为当前位置，并将当前位置设置为0，准备读取缓冲区中的数据。
- rewind()：将当前位置设置为0，准备重新读取缓冲区中的数据。
- clear()：清空缓冲区，将当前位置设置为0，限制位置设置为容量大小，准备写入新数据。
- compact()：压缩缓冲区，将未读取的数据移动到缓冲区的起始位置，以便继续写入新的数据。
- mark()：在当前位置设置标记，用于后续reset()方法的操作。
- reset()：将位置重置为之前标记的位置。
4. 数据操作状态方法：

- hasRemaining()：检查是否还有剩余数据未读取。
- remaining()：获取剩余可读取的数据元素数量。

这些方法使得Buffer类成为一个灵活且高效的数据操作工具。使用这些方法可以方便地读取和写入数据，管理缓冲区的状态，以及实现数据的复制、转移和处理。

```java

    public static void fastCopy(String src, String dist) throws IOException {

        /* 获得源文件的输入字节流 */
        FileInputStream fin = new FileInputStream(src);

        /* 获取输入字节流的文件通道 */
        FileChannel fcin = fin.getChannel();

        /* 获取目标文件的输出字节流 */
        FileOutputStream fout = new FileOutputStream(dist);

        /* 获取输出字节流的通道 */
        FileChannel fcout = fout.getChannel();

        /* 为缓冲区分配 1024 个字节 */
        ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

        while (fcin.read(buffer) != -1) {
            /* read() 返回 -1 表示 EOF */

            /* 切换读写 */
            buffer.flip();

            /* 把缓冲区的内容写入输出文件中 */
            fcout.write(buffer);

            /* 清空缓冲区 */
            buffer.clear();
        }
    }

```

