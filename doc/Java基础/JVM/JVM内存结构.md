![[JVM内存结构 2023-12-28 22.57.52.excalidraw|1000]]



判定一个对象objA是否可回收，至少要经历两次标记过程：
1. 如果对象objA到GC Roots没有引用链，则进行第一次标记。
2. 进行筛选，判断此对象是否有必要执行finalize()方法
3. 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
4. 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
5. ==finalize()方法是对象逃脱死亡的最后机会==，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。





### 哪些部分会出现内存溢出？



### 方法区与永久代、元空间之间的关系



### JVM内存参数



### JVM垃圾回收算法

1. 标记清除
2. 标记整理
3. 标记复制



完整的要点提取

接下来我们来看这道面试题啊, 这道面试题, 它其实的考察点呢在于, 考察大家对java虚拟机内存参数的一个掌握, 我们先来读一下题, 他们有这么一些内存参数, 分别是x m x10240 m x m s, 10240m x m n是5120m, 还有一个survival racial是等于三, 在这样的一个配置参数下, 他们最小内存值是多少, 还有一个survivor区的总大小是多少, 那你要回答这道题, 你是不是得对这些java虚拟机的参数, 它们的含义得了解呀, 我们来分别解读一下啊, 第一个xmx, 这就是指咱们的java训机最大内存是多少, 后面这个小m呢是代表它的单位啊, m是代表罩子减, 那换算一下, 这里的10240m其实就是十个g, 接下来再看第二个, 这个xm s呢就是指java训机的最小内存数啊, 一个是最大一个最小最小内存数也是十个g, 后面这个xmn呢就是指啊, 虚拟机中新生代的内存数啊, 从年代的角度啊, 我们java虚拟内存可以划分成新生代和老年代, 那新生代呢这里占了多少五个g, 那剩下的就是老年代啊, 也是五个g啊, 因为总大小都是十个g嘛, 你新生代占了五个g, 那剩下的五个g就给老年代用, 最后这个survival racial啊, 不太好理解, 我们这儿给一张图啊, 好这里的new就是我们的新生代啊, 新生代新生代其实如果再细分, 又可以分成了伊甸园区和survivor区, survivor呢又分成了from和to啊, 他俩的内存大小总是相等的啊, from和to内存大小总是相等, 那这个survival racial它就是代表了低电园区, 其中survival其中一个部分, 他们的一个内存的占比啊, 注意是内存的一个占比, 比如说我这个图里画的是四比一, 那意思就是说from占一份内存的话, 那一电源就占四份内存, 这个能理解吧, 那么我们的伊甸园from to它们加在一起啊, 是我们新生代的总内存, 那我们这个例子中啊, 新生代的内存是不是五个g, 那你觉得对于我这个例子来讲啊, 他应该是pharm占多大, 你就想是不是应该把它等分成六份啊, 啊注意啊, 伊甸园占了四份, fram占了一份, 但是请大家注意, 还有一个跟from大小相同的to呢对吧, 所以我这个例子中是要把它等分成六份, 然后呢你再看看每一份占多大, 当然据回到我们这个题目啊, 题目这它不是四比, 它是三啊, 它是指一电源跟from它的比例是三啊, 也就是它是它的三倍啊, 那这种情况下呢, 我们应该把它化成均等的五份吧, 啊伊甸园占三份, from和to各占一份啊, 所以那我们把这个新生代这五个g内存, 然后给它除以五啊, 就是每一份占用的内存, 他问的是survivor的总大小, 那就是把from和to都加起来, 也就是再乘以一个二, 所以应该是2048g2048 兆啊, 也就是二两个g好, 那这道题呢我们就回答到这儿, 刚才呢咱们介绍了一个叫survival racial, 这样一个参数, 它呢是控制我们新生代中伊甸园区和from区啊, 之间的一个比例关系, 但是请大家注意啊, 他们的默认值啊, 也就是这个参数的默认值并不是这样的, 四比一啊, 是八比一, 也就是一电源占八份内存的话, from rome占一份, to呢占一份好, 这是默认值, 也请大家了解一下, 另外一个跟按比例设置相关的参数, 比较有用的是这个叫new ritual啊, new ritual呢, 是控制了整个新生代的一个内存占比, 新生代跟谁比呢, 当然跟老年代去比了, 它的默认值是这里的二比一, 也就是老年代占两份内存的话, 那新生代呢占一份好, 这都是按比例设置的两个参数啊, 当然除了按比例设置, 我们也可以直接设置每个区域的大小, 比如说下面这组参数, 我们对新生代呢可以通过这个叫new size, 来设置新生代的一个最小值, 还可以通过这个max new size来设置它的一个最大值, 那最小值不够用了啊, 比如说将来创建对象越来越多了, 它就会自动去扩展扩展的一个上限, 就是这边的max new size, 当然你也可以说啊, 一上来我就把new size跟max new size设成一样的, 不要中间那个扩展过程了, 那这种情况下我们就可以用一个参数啊, 也就是刚才我们也见过的这个差mn, xm参数呢, 就是说啊我的新生代的最小值最大值都一样, 都是这个xm n设置的那个数值啊, 他就不要那个扩展过程了, 好这是新生代的大小控制啊, 对于整个java虚拟机的大小控制呢, 我们已经见过了, 就是这里的xm, 他是说新生代和老年代, 他俩加起来, 也就是咱们的java逊机的最小内存值是多少, 当然了, 它的上限呢我们可以通过这个x mx来控制它, 它的一个上限啊, 就是就是将来这个超过了最小值, 它会扩展扩展到上限, 是这个差mx来控制的, 不过呢建议大家在生产环境中, 把这个叉m s和x mx它们设置为一样的, 也就是我不要那个扩展过程, 那么一上来就让它俩数值相等, 这样呢效率会高一些, 好这都是咱们堆内存的一个设置, 下面呢咱们再来看圆空间的一个内存分类, 其实圆空间啊细分的话, 它又可以把我们的存储的这些类的信息啊, 分成两类, 一类叫class piece, 一类呢叫nonclasspace, 什么意思呢, class space啊, 就是这个类的最基本的信息, 比如说你的类的名称啊, 类的那些方法入口啊, 方法入口它会抽象两个表啊, 一个叫table

点击折叠159行



总结概览要点

4分钟

点击生成

完整的要点提取

一个叫vtable啊, 这个咱们先不展开说啊, 好就是反正是一些类的最基本的信息, 那除此以外像类的那些方法的字节码呀, 类上的那些注解啊, 哎它存储在这个叫non class space里面啊, 分了这么两个区域, 其中这个class space啊, 它是有一个上限的, 它的上限呢是有这个叫compressed class space size啊, 这个参数来控制这个参数啊, 它的初始值是一个g啊, 也就是一开始你这个加载的类的, 这个基本数据没那么多啊, 但是你可以不断的扩展吗, 随着你加载的类越来越多, 你占用的空间也会越来越多, 但是呢它有个上限上限呢, 就是受这个参数的控制, 默认是一个g, 那除了这个class face, 是不是还有个叫non class p, 那么他俩加起来也有个上限, 那这个上限呢是下面这个参数来控制的, 叫做max metadata sense啊, 就是最大圆空间的一个大小, 这个设置啊默认是不设置的, 也就是没有上限啊, 你只要物理内存有多大, 它就可以使这个圆空间, 整个就可以使用多大的内存, 当然你如果设置了, 那么就按你设置的为准好, 这是对原空间的一个内存控制, 下面这个呢这个咱们前面没说过, 他是一个叫cold cash啊, 要叫一个代码缓存, 什么时候会用到这个代码缓存呢, 就是咱们前面讲过一个知识点啊, 就是我们的有一个叫g i t的即时编译器对吧, 他会把那些热点代码进行编译, 编译成机器码, 然后缓存起来, 下次我遇到这种热点代码了, 我就不用经过那个解析的步骤了, 直接到缓存中拿到编译好的机器码, 交给cpu运行, 这样效率就高, 那我们那些机器码是存在哪的呢, 唉就是存在我们这个叫cold cash里面去的, 这个cold cash啊, 分了两种情况, 一种情况就是你的啊有一个叫resolve code catch size, 这个参数, 这个参数如果设置的比较小, 那么小于240兆的话, 那他就把这些编译好的机器码就放在一块了啊, 当然这个呃大小一开始没那么大, 它可以去不断的随着你编译的机器码越来越多, 它会不断增长好, 但是它的总大小是受到这个参数的控制的, 但如果这个参数啊我设置的是大于240啊, 那么它就会对这个优化后的这些机器代码, 进行一个细分啊, 分成三个区域, 哪三个区域呢, 一个叫nn method, 这个是啊, 那个g i t编译器自己用的一些代码啊, 就是一些啊jvm内部啊, 自己的一些代码存在这个叫nn method, 这个区域里面, 经过部分优化的代码, 它放在这个叫profile n methods, 这个区别经过完整优化的代码啊, 放在这个叫nonprofiln methods这个区域啊, 他们的总大小啊是受到这个叫reserve的code, catch size, 它的一个控制好在这个区域啊, 大家就记住它, 它叫做代码缓存区啊, 这个代码缓存区就是缓存编译后的, 那些机器码的最后一个参数啊, 大家要知道的就是一个xss啊, 它是控制每个线程啊占用的内存的啊, 每个县城就是咱说的那个虚拟机站啊, 虚拟战每个虚拟站有多大的内存, 受到这个差s s这个参数的控制, 如果你不设置啊啊它是跟操作系统有关, 如果是linux操作系统, 64位的linux操作系统会占用每个线程, 会占一兆的内存啊, 你可以通过这个参数来自行调整好了, 讲到这儿呢, 我们常见的一些java讯息参数就介绍完毕了啊, 如果想知道更多的这个java虚拟参数呢, 可以查阅一下它的官方文档啊

点击折叠97行

💡提示💡

可以尝试将概览生成的内容粘贴到视频评论里，发布后看看有什么效果🥳

点击复制生成的要点

![youtube subtitle](chrome-extension://bciglihaegkdhoogebcdblfhppoilclp/youtube-subtitle.png)Youtube Subtitle

这是Youtube版的字幕列表

[Chrome商店](https://chromewebstore.google.com/detail/fiaeclpicddpifeflpmlgmbjgaedladf)[Edge商店](https://microsoftedge.microsoft.com/addons/detail/galeejdehabppfgooagmkclpppnbccpc)



完整的要点提取

接下来我们来看这道面试题啊, 这道面试题, 它其实的考察点呢在于, 考察大家对java虚拟机内存参数的一个掌握, 我们先来读一下题, 他们有这么一些内存参数, 分别是x m x10240 m x m s, 10240m x m n是5120m, 还有一个survival racial是等于三, 在这样的一个配置参数下, 他们最小内存值是多少, 还有一个survivor区的总大小是多少, 那你要回答这道题, 你是不是得对这些java虚拟机的参数, 它们的含义得了解呀, 我们来分别解读一下啊, 第一个xmx, 这就是指咱们的java训机最大内存是多少, 后面这个小m呢是代表它的单位啊, m是代表罩子减, 那换算一下, 这里的10240m其实就是十个g, 接下来再看第二个, 这个xm s呢就是指java训机的最小内存数啊, 一个是最大一个最小最小内存数也是十个g, 后面这个xmn呢就是指啊, 虚拟机中新生代的内存数啊, 从年代的角度啊, 我们java虚拟内存可以划分成新生代和老年代, 那新生代呢这里占了多少五个g, 那剩下的就是老年代啊, 也是五个g啊, 因为总大小都是十个g嘛, 你新生代占了五个g, 那剩下的五个g就给老年代用, 最后这个survival racial啊, 不太好理解, 我们这儿给一张图啊, 好这里的new就是我们的新生代啊, 新生代新生代其实如果再细分, 又可以分成了伊甸园区和survivor区, survivor呢又分成了from和to啊, 他俩的内存大小总是相等的啊, from和to内存大小总是相等, 那这个survival racial它就是代表了低电园区, 其中survival其中一个部分, 他们的一个内存的占比啊, 注意是内存的一个占比, 比如说我这个图里画的是四比一, 那意思就是说from占一份内存的话, 那一电源就占四份内存, 这个能理解吧, 那么我们的伊甸园from to它们加在一起啊, 是我们新生代的总内存, 那我们这个例子中啊, 新生代的内存是不是五个g, 那你觉得对于我这个例子来讲啊, 他应该是pharm占多大, 你就想是不是应该把它等分成六份啊, 啊注意啊, 伊甸园占了四份, fram占了一份, 但是请大家注意, 还有一个跟from大小相同的to呢对吧, 所以我这个例子中是要把它等分成六份, 然后呢你再看看每一份占多大, 当然据回到我们这个题目啊, 题目这它不是四比, 它是三啊, 它是指一电源跟from它的比例是三啊, 也就是它是它的三倍啊, 那这种情况下呢, 我们应该把它化成均等的五份吧, 啊伊甸园占三份, from和to各占一份啊, 所以那我们把这个新生代这五个g内存, 然后给它除以五啊, 就是每一份占用的内存, 他问的是survivor的总大小, 那就是把from和to都加起来, 也就是再乘以一个二, 所以应该是2048g2048 兆啊, 也就是二两个g好, 那这道题呢我们就回答到这儿, 刚才呢咱们介绍了一个叫survival racial, 这样一个参数, 它呢是控制我们新生代中伊甸园区和from区啊, 之间的一个比例关系, 但是请大家注意啊, 他们的默认值啊, 也就是这个参数的默认值并不是这样的, 四比一啊, 是八比一, 也就是一电源占八份内存的话, from rome占一份, to呢占一份好, 这是默认值, 也请大家了解一下, 另外一个跟按比例设置相关的参数, 比较有用的是这个叫new ritual啊, new ritual呢, 是控制了整个新生代的一个内存占比, 新生代跟谁比呢, 当然跟老年代去比了, 它的默认值是这里的二比一, 也就是老年代占两份内存的话, 那新生代呢占一份好, 这都是按比例设置的两个参数啊, 当然除了按比例设置, 我们也可以直接设置每个区域的大小, 比如说下面这组参数, 我们对新生代呢可以通过这个叫new size, 来设置新生代的一个最小值, 还可以通过这个max new size来设置它的一个最大值, 那最小值不够用了啊, 比如说将来创建对象越来越多了, 它就会自动去扩展扩展的一个上限, 就是这边的max new size, 当然你也可以说啊, 一上来我就把new size跟max new size设成一样的, 不要中间那个扩展过程了, 那这种情况下我们就可以用一个参数啊, 也就是刚才我们也见过的这个差mn, xm参数呢, 就是说啊我的新生代的最小值最大值都一样, 都是这个xm n设置的那个数值啊, 他就不要那个扩展过程了, 好这是新生代的大小控制啊, 对于整个java虚拟机的大小控制呢, 我们已经见过了, 就是这里的xm, 他是说新生代和老年代, 他俩加起来, 也就是咱们的java逊机的最小内存值是多少, 当然了, 它的上限呢我们可以通过这个x mx来控制它, 它的一个上限啊, 就是就是将来这个超过了最小值, 它会扩展扩展到上限, 是这个差mx来控制的, 不过呢建议大家在生产环境中, 把这个叉m s和x mx它们设置为一样的, 也就是我不要那个扩展过程, 那么一上来就让它俩数值相等, 这样呢效率会高一些, 好这都是咱们堆内存的一个设置, 下面呢咱们再来看圆空间的一个内存分类, 其实圆空间啊细分的话, 它又可以把我们的存储的这些类的信息啊, 分成两类, 一类叫class piece, 一类呢叫nonclasspace, 什么意思呢, class space啊, 就是这个类的最基本的信息, 比如说你的类的名称啊, 类的那些方法入口啊, 方法入口它会抽象两个表啊, 一个叫table

点击折叠159行



总结概览要点

4分钟

点击生成

完整的要点提取

一个叫vtable啊, 这个咱们先不展开说啊, 好就是反正是一些类的最基本的信息, 那除此以外像类的那些方法的字节码呀, 类上的那些注解啊, 哎它存储在这个叫non class space里面啊, 分了这么两个区域, 其中这个class space啊, 它是有一个上限的, 它的上限呢是有这个叫compressed class space size啊, 这个参数来控制这个参数啊, 它的初始值是一个g啊, 也就是一开始你这个加载的类的, 这个基本数据没那么多啊, 但是你可以不断的扩展吗, 随着你加载的类越来越多, 你占用的空间也会越来越多, 但是呢它有个上限上限呢, 就是受这个参数的控制, 默认是一个g, 那除了这个class face, 是不是还有个叫non class p, 那么他俩加起来也有个上限, 那这个上限呢是下面这个参数来控制的, 叫做max metadata sense啊, 就是最大圆空间的一个大小, 这个设置啊默认是不设置的, 也就是没有上限啊, 你只要物理内存有多大, 它就可以使这个圆空间, 整个就可以使用多大的内存, 当然你如果设置了, 那么就按你设置的为准好, 这是对原空间的一个内存控制, 下面这个呢这个咱们前面没说过, 他是一个叫cold cash啊, 要叫一个代码缓存, 什么时候会用到这个代码缓存呢, 就是咱们前面讲过一个知识点啊, 就是我们的有一个叫g i t的即时编译器对吧, 他会把那些热点代码进行编译, 编译成机器码, 然后缓存起来, 下次我遇到这种热点代码了, 我就不用经过那个解析的步骤了, 直接到缓存中拿到编译好的机器码, 交给cpu运行, 这样效率就高, 那我们那些机器码是存在哪的呢, 唉就是存在我们这个叫cold cash里面去的, 这个cold cash啊, 分了两种情况, 一种情况就是你的啊有一个叫resolve code catch size, 这个参数, 这个参数如果设置的比较小, 那么小于240兆的话, 那他就把这些编译好的机器码就放在一块了啊, 当然这个呃大小一开始没那么大, 它可以去不断的随着你编译的机器码越来越多, 它会不断增长好, 但是它的总大小是受到这个参数的控制的, 但如果这个参数啊我设置的是大于240啊, 那么它就会对这个优化后的这些机器代码, 进行一个细分啊, 分成三个区域, 哪三个区域呢, 一个叫nn method, 这个是啊, 那个g i t编译器自己用的一些代码啊, 就是一些啊jvm内部啊, 自己的一些代码存在这个叫nn method, 这个区域里面, 经过部分优化的代码, 它放在这个叫profile n methods, 这个区别经过完整优化的代码啊, 放在这个叫nonprofiln methods这个区域啊, 他们的总大小啊是受到这个叫reserve的code, catch size, 它的一个控制好在这个区域啊, 大家就记住它, 它叫做代码缓存区啊, 这个代码缓存区就是缓存编译后的, 那些机器码的最后一个参数啊, 大家要知道的就是一个xss啊, 它是控制每个线程啊占用的内存的啊, 每个县城就是咱说的那个虚拟机站啊, 虚拟战每个虚拟站有多大的内存, 受到这个差s s这个参数的控制, 如果你不设置啊啊它是跟操作系统有关, 如果是linux操作系统, 64位的linux操作系统会占用每个线程, 会占一兆的内存啊, 你可以通过这个参数来自行调整好了, 讲到这儿呢, 我们常见的一些java讯息参数就介绍完毕了啊, 如果想知道更多的这个java虚拟参数呢, 可以查阅一下它的官方文档啊

点击折叠97行

💡提示💡

可以尝试将概览生成的内容粘贴到视频评论里，发布后看看有什么效果🥳

点击复制生成的要点

![youtube subtitle](chrome-extension://bciglihaegkdhoogebcdblfhppoilclp/youtube-subtitle.png)Youtube Subtitle

这是Youtube版的字幕列表

[Chrome商店](https://chromewebstore.google.com/detail/fiaeclpicddpifeflpmlgmbjgaedladf)[Edge商店](https://microsoftedge.microsoft.com/addons/detail/galeejdehabppfgooagmkclpppnbccpc)





好咱们继续, 刚才介绍了方法区, 堆程序计数器, 虚拟站, 本地方法栈这五块内存区, 那针对他们呢, 面试官还有可能这样来问啊, 他们这一区里面哪些有可能产生内存溢出, 什么叫内存溢出啊, 其实就是指该区域的内存被耗尽了, 报错了, 这叫做内存溢出, 哪些区域啊, 其实除了我们的程序计数器这个区域以外, 其他四个区域都有可能产生内存溢出啊, 也就是程序计数器啊, 不会产生内存溢出啊, 其他都有可能产生内存溢出啊, 又分成了两种错误类型, 一种呢是这个out of memory error, 另外一种呢是stack offerror, 那咱们分别来看什么情况下, 会产生这个out of memory error呢, 第一种情况就是我们的堆内存耗尽了, 会出现out of memory error, linux啊我们都知道是用来存储对象的, 当你的对象创建的越来越多, 那这些对象呢又一直在被使用, 一直使用, 意味着他们不能被垃圾回收, 因为垃圾回收呢, 只能释放那些不再被引用的对象, 他们所占用的内存, 如果你这个对象一直在被用着, 那么垃圾回收不能清理它们的内存, 这样呢就造成了我的堆内存, 最终啊内存耗尽就会出现这个out of memory error, 这是第一种情况啊, 第二种情况呢是我们的方法区的内存耗尽, 方法区呢咱们都知道它是用来存储类的信息的, z的信息来源有两个, 一个呢是我们啊自己通过类加载, 从磁盘上加载到的类, 另外一种呢就是在运行期间, 也有可能产生一些新的问, 比如说我们的很多框架spring啊, 什么my base啊, 这些框架他们都有这种需求, 需要在运行期间产生新的类啊, 比如说作为什么代理类之类的, 那无论是哪种来源吧, 不管是你加载的还是运行期间新产生的, 那这些类他们都要占用方法区的内存啊, 都要占用方形内存, 而方法区内存啊, 我们也是可以给他设置上限的, 如果lead占用内存, 超过了方法区设置的那个上限, 那也会出现out of memory error, 不过这种情况一般比较少, 因为我们默认情况下, 这个方法区它的内存是没有设置上限, 也就是物理内存有多大, 你方法区就能用多大的内存啊, 所以一般来讲, 这种方法区内存耗尽的情况非常少见, 第三种情况是线程占用的内存太多了, 每创建一个线程, 这个线程最多就会占用一兆的内存啊, 默认情况会占用一兆, 那随着你的线程个数越来越多, 而这些线程啊又长时间运行, 不销毁的时候, 那最终累积起来的内存也会导致内存耗尽, 出现这个out of memory error, 其实啊如果这个线程我们运行完了啊, 它线程代码结束了, 那么它占用的内存自然会被释放掉, 就怕你编程不当, 导致这个线程一直在长时间运行啊, 你不销毁, 那它占用的内存也不会释放啊, 这样最终也会出现out of memory error, 好这是三种出现out of memory error的情况, 最后一种是出现这个stack overflow error的情况, 它呢是每个线程内部, 由于方法调用次数过多导致的, 那有同学说方法次数怎么会调用过多呢, 哎有可能也是由于你的编程失误啊, 比如说你来了一个递归调用, 但是呢你又没有正确编写那个递归的终止条件, 那自然就会导致这个方法在不断的调用, 肯定是无限循环下去啊, 就会造成你的方法调用次数过多, 每一次方法调用呢, 都会从我们县城中的这一兆内存中分一点内存, 给你这个方法调用使用, 那自然如果你无限调用这个方法调用下去, 肯定会把这一兆内存就消耗掉啊, 这个县城内的这一兆内存啊, 耗尽了就会出现这个stack overflow erro, 对于三四这两种情况, 大家要把它们区分开啊, 那第三种情况是由于线程个数太多啊, 每个线程占用内存累积起来, 造成我们的内存耗尽, 第四种情况呢是我们县城内啊, 方法调用次数过多, 把你这县城内的这一兆内存耗尽了啊, 这时候出现的是啊, stack overflow erro好了, 针对这四种内存溢出的情况, 我们就给https://microsoftedge.microsoft.com/addons/detail/galeejdehabppfgooagmkclpppnbccpc)
