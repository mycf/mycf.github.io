CMS 收集器是 JDK5 发布的一款收集器：而 G1是 JDK7发布，JDK9 作为默认的垃圾收集器。JDK9发布之日，G1 宣告取代Parallel Scavenge + Parallel Old 的组合，成为服务端模式下的默认收集器，而 CMS 则沦落至被声明为不推荐使用的收集器。不过，从它出现几年仍不能在所有场景中取代 CMS 就可以得知：G1 相对于CMS 也不是占全方位、压倒性优势的。接下来让我们分别看下他们实现上的区别和优劣势。

两者都是非常关注停顿时间的多线程并发收集器，从实现上看，他们的区别如下

1. 回收的位置不同
- CMS：老年代，
- G1：新生代和老年代。

2. 垃圾回收算法不同。
- CMS：标记-清除算法
- G1：标记-整理算法。

3. 解决漏标的方式不同。
- CMS：增量更新。
- G1：原始快照。

4. 是否产生内存碎片。
- CMS：会产生内存碎片。
- G1：不会产生内存碎片。

5. 是否可预测STW时长。
- CMS：无法预测。
- G1：可以预测。

6. 堆内存适用大小不同。
- CMS：一般建议 4~8G。
- G1：建议 8G 以上。

最后让我们比较下 G1 相对于 CMS 的优劣势 :
- 优势:可以指定最大停顿时间、分 Region 的内存分布、按收益动态确定回收集、不会产生空间碎片等
- 劣势:主要是G1采用分 Region 的内存分布而带来的记忆集的维护成本更高，所以垃圾收集产生的内存占用和程序运行时的额外执行负载都会比 CMS 要高。
