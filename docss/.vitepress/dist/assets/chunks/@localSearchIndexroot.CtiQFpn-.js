const t='{"documentCount":39,"nextId":39,"documentIds":{"0":"/java基础/arraylist.html#modcount","1":"/java基础/arraylist.html#自动扩容","2":"/java基础/jvm/g1收集器.html#介绍","3":"/java基础/jvm/g1收集器.html#关于-g1-的内存布局-总结以下几点","4":"/java基础/jvm/g1收集器.html#垃圾收集分类","5":"/java基础/jvm/g1收集器.html#younggc","6":"/java基础/jvm/g1收集器.html#mixedgc","7":"/java基础/jvm/g1收集器.html#fullgc","8":"/java基础/jvm/g1收集器.html#gc过程","9":"/java基础/jvm/g1收集器.html#说说g1的优缺点","10":"/java基础/jvm/g1收集器.html#停顿预测模型","11":"/java基础/jvm/g1收集器.html#期望停顿时间是否可以随意设置","12":"/java基础/jvm/g1收集器.html#g1收集器的空间分配","13":"/java基础/jvm/g1收集器.html#参数设置","14":"/java基础/jvm/zgc收集器.html#垃圾收集过程","15":"/netty/linux/rg.html#排除文件类型","16":"/设计模式/六大设计原则.html#六大设计原则","17":"/设计模式/六大设计原则.html#单一职责原则","18":"/设计模式/六大设计原则.html#里氏替换原则","19":"/设计模式/六大设计原则.html#依赖倒置原则","20":"/设计模式/六大设计原则.html#接口隔离原则","21":"/设计模式/六大设计原则.html#迪米特法则","22":"/设计模式/六大设计原则.html#开闭原则","23":"/设计模式/创建型模式.html#抽象工厂模式","24":"/设计模式/创建型模式.html#建造者模式","25":"/设计模式/创建型模式.html#工厂方法模式","26":"/设计模式/创建型模式.html#原型模式","27":"/设计模式/创建型模式.html#my-anchor","28":"/设计模式/行为型模式.html#责任链模式","29":"/设计模式/行为型模式.html#命令模式","30":"/设计模式/行为型模式.html#解释器模式","31":"/设计模式/行为型模式.html#迭代器","32":"/设计模式/行为型模式.html#中介者","33":"/设计模式/行为型模式.html#备忘录","34":"/设计模式/行为型模式.html#观察者","35":"/设计模式/行为型模式.html#状态","36":"/设计模式/行为型模式.html#策略","37":"/设计模式/行为型模式.html#模板方法","38":"/设计模式/行为型模式.html#访问者"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,36],"1":[1,1,143],"2":[1,1,21],"3":[5,1,37],"4":[1,1,7],"5":[1,1,26],"6":[1,1,24],"7":[1,1,15],"8":[1,1,40],"9":[1,1,18],"10":[1,1,28],"11":[2,1,23],"12":[1,1,36],"13":[1,1,51],"14":[1,1,84],"15":[1,1,10],"16":[1,1,1],"17":[1,1,18],"18":[1,1,8],"19":[1,1,6],"20":[1,1,2],"21":[1,1,12],"22":[1,1,4],"23":[1,1,7],"24":[1,1,3],"25":[1,1,5],"26":[1,1,3],"27":[1,1,13],"28":[1,1,1],"29":[1,1,1],"30":[1,1,1],"31":[1,1,1],"32":[1,1,1],"33":[1,1,1],"34":[1,1,1],"35":[1,1,1],"36":[1,1,1],"37":[1,1,1],"38":[1,1,1]},"averageFieldLength":[1.1282051282051282,1,17.743589743589748],"storedFields":{"0":{"title":"modCount","titles":[]},"1":{"title":"自动扩容","titles":[]},"2":{"title":"介绍","titles":[]},"3":{"title":"关于 G1 的内存布局，总结以下几点：","titles":[]},"4":{"title":"垃圾收集分类","titles":[]},"5":{"title":"YoungGC","titles":["垃圾收集分类"]},"6":{"title":"MixedGC","titles":["垃圾收集分类"]},"7":{"title":"FullGC","titles":["垃圾收集分类"]},"8":{"title":"GC过程","titles":[]},"9":{"title":"说说G1的优缺点","titles":[]},"10":{"title":"停顿预测模型","titles":[]},"11":{"title":"期望停顿时间是否可以随意设置？","titles":[]},"12":{"title":"G1收集器的空间分配","titles":[]},"13":{"title":"参数设置","titles":[]},"14":{"title":"垃圾收集过程","titles":[]},"15":{"title":"排除文件类型","titles":[]},"16":{"title":"六大设计原则","titles":[]},"17":{"title":"单一职责原则","titles":["六大设计原则"]},"18":{"title":"里氏替换原则","titles":["六大设计原则"]},"19":{"title":"依赖倒置原则","titles":["六大设计原则"]},"20":{"title":"接口隔离原则","titles":["六大设计原则"]},"21":{"title":"迪米特法则","titles":["六大设计原则"]},"22":{"title":"开闭原则","titles":["六大设计原则"]},"23":{"title":"抽象工厂模式","titles":[]},"24":{"title":"建造者模式","titles":[]},"25":{"title":"工厂方法模式","titles":[]},"26":{"title":"原型模式","titles":[]},"27":{"title":"单例模式","titles":[]},"28":{"title":"责任链模式","titles":[]},"29":{"title":"命令模式","titles":[]},"30":{"title":"解释器模式","titles":[]},"31":{"title":"迭代器","titles":[]},"32":{"title":"中介者","titles":[]},"33":{"title":"备忘录","titles":[]},"34":{"title":"观察者","titles":[]},"35":{"title":"状态","titles":[]},"36":{"title":"策略","titles":[]},"37":{"title":"模板方法","titles":[]},"38":{"title":"访问者","titles":[]}},"dirtCount":0,"index":[["访问者",{"0":{"38":1}}],["模板方法",{"0":{"37":1}}],["模块和函数应该对扩展开放",{"2":{"22":1}}],["策略",{"0":{"36":1}}],["状态",{"0":{"35":1}}],["观察者",{"0":{"34":1}}],["备忘录",{"0":{"33":1}}],["迭代器",{"0":{"31":1}}],["迭代器会立即抛出",{"2":{"0":1}}],["迭代器会记录当前的",{"2":{"0":1}}],["解释器模式",{"0":{"30":1}}],["命令模式",{"0":{"29":1}}],["责任链模式",{"0":{"28":1}}],["diagram",{"2":{"27":3}}],["demeter",{"2":{"21":1}}],["default",{"2":{"1":1}}],["defaultcapacity",{"2":{"1":1}}],["确保某一个类只有一个实例",{"2":{"27":1}}],["单例模式",{"0":{"27":1}}],["单一职责原则的定义是",{"2":{"17":1}}],["单一职责原则",{"0":{"17":1}}],["让子类决定实例化哪一个类",{"2":{"25":1}}],["让我们逐步解释这行代码的含义",{"2":{"1":1}}],["定义一个用于创建对象的接口",{"2":{"25":1}}],["工厂方法模式",{"0":{"25":1}}],["建造者模式",{"0":{"24":1}}],["而且自行实例化并向整个系统提供这个实例",{"2":{"27":1}}],["而且替换为子类也不会产生任何错误或异常",{"2":{"18":1}}],["而无须指定它们具体的类",{"2":{"23":1}}],["抽象工厂",{"2":{"23":1}}],["抽象工厂模式",{"0":{"23":1}}],["开闭原则",{"0":{"22":1}}],["开始对堆中对象进行可达性分析",{"2":{"8":1}}],["开始采用多线程",{"2":{"7":1}}],["开始推出",{"2":{"2":1}}],["开始进行扩容",{"2":{"1":1}}],["knowledge",{"2":{"21":1}}],["也称为最少知识原则",{"2":{"21":1}}],["也就是占整个堆空间的",{"2":{"12":2}}],["迪米特法则",{"0":{"21":1},"2":{"21":1}}],["客户端不应该依赖它不需要的接口",{"2":{"20":1}}],["接口隔离原则",{"0":{"20":1}}],["实现类之间不发生直接的依赖关系",{"2":{"19":1}}],["实现什么职责都有清晰明确的定义",{"2":{"17":1}}],["依赖倒置原则",{"0":{"19":1}}],["父类未必就能适应",{"2":{"18":1}}],["有子类出现的地方",{"2":{"18":1}}],["只要父类能出现的地方子类就可以出现",{"2":{"18":1}}],["里氏替换原则",{"0":{"18":1}}],["维护性都有非常大的帮助",{"2":{"17":1}}],["维护一个转发表",{"2":{"14":1}}],["对象创建型模式",{"2":{"23":1}}],["对修改关闭",{"2":{"22":1}}],["对其他的接口无影响",{"2":{"17":1}}],["对于超过整个",{"2":{"3":1}}],["变更是必不可少的",{"2":{"17":1}}],["复杂性降低",{"2":{"17":1}}],["复制算法",{"2":{"6":1}}],["❑实现类依赖接口或抽象类",{"2":{"19":1}}],["❑接口或抽象类不依赖于实现类",{"2":{"19":1}}],["❑模块间的依赖通过抽象发生",{"2":{"19":1}}],["❑变更引起的风险降低",{"2":{"17":1}}],["❑可维护性提高",{"2":{"17":1}}],["❑可读性提高",{"2":{"17":1}}],["❑类的复杂性降低",{"2":{"17":1}}],["应该有且仅有一个原因引起类的变更",{"2":{"17":1}}],["应用运行久了",{"2":{"11":1}}],["六大设计原则",{"0":{"16":1},"1":{"17":1,"18":1,"19":1,"20":1,"21":1,"22":1}}],["排除",{"2":{"15":1}}],["排除文件类型",{"0":{"15":1}}],["搜索内容",{"2":{"15":2}}],["原型模式",{"0":{"26":1}}],["原来记录新旧关系的转发表就可以释放掉了",{"2":{"14":1}}],["原始快照",{"2":{"8":1}}],["反过来就不行了",{"2":{"18":1}}],["反正它们都是要遍历对象",{"2":{"14":1}}],["反而降低性能",{"2":{"11":1}}],["合并到了下一次gc中的并发标记阶段里去完成",{"2":{"14":1}}],["很巧妙的将并发重映射阶段要做的工作",{"2":{"14":1}}],["很可能出现的结果就是由于停顿时间太短",{"2":{"11":1}}],["去完成的任务",{"2":{"14":1}}],["迫切",{"2":{"14":1}}],["但是",{"2":{"14":1,"18":1}}],["但如果我们把停顿时间调得非常低",{"2":{"11":1}}],["该阶段所做的主要是修正整个堆中指向重分配集中旧对象的所有引用",{"2":{"14":1}}],["该阶段是",{"2":{"14":1}}],["能力",{"2":{"14":1}}],["能够在需要时动态调整容量",{"2":{"1":1}}],["自愈",{"2":{"14":1}}],["自动扩容",{"0":{"1":1}}],["使得同样的构建过程可以创建不同的表示",{"2":{"24":1}}],["使其直接指向新对象",{"2":{"14":1}}],["使用者可能根本就不需要知道是父类还是子类",{"2":{"18":1}}],["使用g1收集器",{"2":{"13":1}}],["使用",{"2":{"7":1}}],["读屏障",{"2":{"14":1}}],["得益于颜色指针的支持",{"2":{"14":1}}],["得到新的容量",{"2":{"1":1}}],["记录从旧对象到新对象的转向关系",{"2":{"14":1}}],["上的转发表记录将访问转发到新复制的对象上",{"2":{"14":1}}],["上",{"2":{"14":1}}],["执行过程中的核心阶段",{"2":{"14":1}}],["相反",{"2":{"14":1}}],["相当于将",{"2":{"1":1}}],["那当然更容易维护了",{"2":{"17":1}}],["那当然可读性提高了",{"2":{"17":1}}],["那样做收益优先的增量回收",{"2":{"14":1}}],["那么才会触发young",{"2":{"5":1}}],["那么增加年轻代的",{"2":{"5":1}}],["那么",{"2":{"1":1,"12":1}}],["划分",{"2":{"14":1}}],["还是有区别的",{"2":{"14":1}}],["还具备高吞吐量性能特征",{"2":{"2":1}}],["重分配集与",{"2":{"14":1}}],["组成重分配集",{"2":{"14":1}}],["zgc",{"2":{"14":9}}],["尽管",{"2":{"14":1}}],["前后也要经过类似",{"2":{"14":1}}],["与",{"2":{"14":2}}],["与用户线程并发执行",{"2":{"8":1}}],["个阶段",{"2":{"14":1}}],["个连续的",{"2":{"3":1}}],["4",{"2":{"14":1}}],["垃圾收集过程",{"0":{"14":1}}],["垃圾收集分类",{"0":{"4":1},"1":{"5":1,"6":1,"7":1}}],["一个软件实体如类",{"2":{"22":1}}],["一个类应该对自己需要耦合或调用的类知道得最少",{"2":{"21":1}}],["一个接口修改只对相应的实现类有影响",{"2":{"17":1}}],["一旦所有的指针被修正之后",{"2":{"14":1}}],["一会再开始回收",{"2":{"13":1}}],["一般来说回收阶段占到",{"2":{"11":1}}],["恢复系统运行",{"2":{"13":1}}],["存活对象过多",{"2":{"13":1}}],["则执行新生代和老年代的混合收集",{"2":{"13":1}}],["最多只是第一次使用时多一次转发和修正操作",{"2":{"14":1}}],["最大年龄值",{"2":{"13":1}}],["最终会占满堆引发",{"2":{"11":1}}],["最终标记",{"2":{"8":1,"14":1}}],["含",{"2":{"13":1}}],["此时就会把年龄n",{"2":{"13":1}}],["总和超过了survivor区域的50",{"2":{"13":1}}],["总结以下几点",{"0":{"3":1}}],["年龄1+年龄2+年龄n的多个年龄对象",{"2":{"13":1}}],["目标允许的暂停时间",{"2":{"13":1}}],["且必须是2的n次幂",{"2":{"13":1}}],["且应为",{"2":{"3":1}}],["指定分区大小",{"2":{"13":1}}],["指定gc工作的线程数量",{"2":{"13":1}}],["区占比仍然是为8",{"2":{"12":1}}],["区和",{"2":{"12":1}}],["区域能够承载拷贝对象",{"2":{"6":1}}],["区域",{"2":{"3":2,"5":1}}],["60",{"2":{"12":1,"13":1}}],["用原型实例指定创建对象的种类",{"2":{"26":1}}],["用来控制新生代的大小",{"2":{"12":1}}],["用于记录对",{"2":{"0":1}}],["老年代占用空间达到整堆内存阈值",{"2":{"13":1}}],["老年代",{"2":{"12":2}}],["老年代的堆占有率",{"2":{"6":1}}],["既然",{"2":{"12":1}}],["譬如设置为",{"2":{"11":1}}],["期望停顿时间是否可以随意设置",{"0":{"11":1}}],["优先选择回收价值最大的",{"2":{"10":1}}],["优点",{"2":{"9":1}}],["置信度等统计信息",{"2":{"10":1}}],["标志位",{"2":{"14":1}}],["标准偏差",{"2":{"10":1}}],["标记阶段会更新颜色指针的",{"2":{"14":1}}],["标记",{"2":{"9":1}}],["为60",{"2":{"12":1}}],["为理论基础来实现的",{"2":{"10":1}}],["为了避免频繁的扩容操作",{"2":{"1":1}}],["为了防止出现不确定的行为",{"2":{"0":1}}],["衰减均值",{"2":{"10":1}}],["毫秒会是比较合理的",{"2":{"11":1}}],["毫秒左右都很正常",{"2":{"11":1}}],["毫秒",{"2":{"10":1,"11":2}}],["默认8次",{"2":{"13":1}}],["默认85",{"2":{"13":1}}],["默认45",{"2":{"13":1}}],["默认15",{"2":{"13":1}}],["默认50",{"2":{"13":1}}],["默认200ms",{"2":{"13":1}}],["默认情况下",{"2":{"12":1}}],["默认的停顿目标为",{"2":{"11":1}}],["默认值",{"2":{"10":1,"13":2}}],["默认最多可以有",{"2":{"3":1}}],["我们可以根据参数",{"2":{"10":1}}],["型",{"2":{"10":1}}],["可读性提高",{"2":{"17":1}}],["可预测的停顿时间模",{"2":{"10":1}}],["可以通过参数",{"2":{"12":1}}],["可以通过构造函数初始化一个足够大的初始容量",{"2":{"1":1}}],["可以继续使用原有参数",{"2":{"12":1}}],["可以指定最大停顿时间",{"2":{"9":1}}],["可以自由选择任意多个",{"2":{"8":1}}],["可以在一定程度上减少频繁扩容的次数",{"2":{"1":1}}],["可以在迭代过程中及时检测到结构修改",{"2":{"0":1}}],["停顿预测模型",{"0":{"10":1}}],["停止系统程序",{"2":{"7":1}}],["都需要维护一份卡表",{"2":{"9":1}}],["都可以根据需要",{"2":{"3":1}}],["堆中每一个region",{"2":{"9":1}}],["堆划分为多个大小相等的独立区域",{"2":{"3":1}}],["导致垃圾慢慢堆积",{"2":{"11":1}}],["导致每次选出来的目标回收集只占堆内存很小的一部分",{"2":{"11":1}}],["导致",{"2":{"9":1}}],["恰恰是因为采用",{"2":{"9":1}}],["缺点",{"2":{"9":1}}],["无空间碎片",{"2":{"9":1}}],["整理算法",{"2":{"9":1}}],["采用",{"2":{"9":1}}],["采用单线程进行标记",{"2":{"7":1}}],["分析得到平均值",{"2":{"10":1}}],["分",{"2":{"9":1}}],["说说g1的优缺点",{"0":{"9":1}}],["所截获",{"2":{"14":1}}],["所以需要",{"2":{"8":1}}],["所有区域",{"2":{"7":1}}],["再清理掉整个旧",{"2":{"8":1}}],["构成会收集",{"2":{"8":1}}],["首先对各个region",{"2":{"8":1}}],["筛选回收",{"2":{"8":1}}],["处理并发标记阶段遗留下来的少量的",{"2":{"8":1}}],["从而造成内存占用和额外执行负载比较高",{"2":{"9":1}}],["从",{"2":{"8":1}}],["roots",{"2":{"8":1}}],["roots直接能引用的对象速度很快",{"2":{"8":1}}],["remove",{"2":{"27":1}}],["remap",{"2":{"14":1}}],["remark",{"2":{"8":1}}],["relocation",{"2":{"14":1}}],["relocate",{"2":{"14":2}}],["regon",{"2":{"10":1}}],["region",{"2":{"2":1,"3":6,"5":2,"6":2,"7":1,"8":4,"9":2,"13":2,"14":5}}],["return",{"2":{"1":7}}],["暂停所有的其他线程",{"2":{"8":1}}],["初始标记",{"2":{"8":1}}],["过程大致分为以下几个步骤",{"2":{"8":1}}],["来设置",{"2":{"12":1}}],["来设置允许的停顿时间",{"2":{"10":1}}],["来供下次",{"2":{"7":1}}],["来计算新的容量",{"2":{"1":1}}],["主要是为了能够空闲出来一批",{"2":{"7":1}}],["主要使用标记",{"2":{"6":1}}],["清理和压缩整理",{"2":{"7":1}}],["全堆扫描",{"2":{"7":1}}],["全功能垃圾收集器",{"2":{"2":1}}],["拷贝过程如果发现没有足够的",{"2":{"6":1}}],["需要把各个",{"2":{"6":1}}],["需要注意的是",{"2":{"1":1}}],["lkp",{"2":{"21":1}}],["least",{"2":{"21":1}}],["length",{"2":{"1":2}}],["lod",{"2":{"21":1}}],["law",{"2":{"21":1}}],["lnitiatingheapoccupancypercent",{"2":{"6":1}}],["参数设置",{"0":{"13":1}}],["参数",{"2":{"6":1}}],["达到",{"2":{"6":1}}],["触发的条件",{"2":{"6":1}}],["大概分为",{"2":{"14":1}}],["大对象区域",{"2":{"6":1}}],["大小或导致迭代器失效的操作",{"2":{"0":1}}],["根据用户所期望的gc停顿时间来制定回收计划",{"2":{"8":1}}],["根据期望的gc停顿时间确定回收收益最大的old区域",{"2":{"6":1}}],["根据一定的策略进行扩容",{"2":{"1":1}}],["计算回收时间接近参数",{"2":{"5":1}}],["放满",{"2":{"5":1}}],["直到下一次",{"2":{"5":1}}],["young",{"2":{"5":1}}],["younggc",{"0":{"5":1},"2":{"4":1,"5":1}}],["不会马上做",{"2":{"5":1}}],["继续给新对象存放",{"2":{"5":1}}],["继续添加新元素到",{"2":{"1":1}}],["设定的值",{"2":{"5":2,"6":1}}],["设置最大堆的大小",{"2":{"12":1}}],["设置堆的初始大小",{"2":{"12":1}}],["设置",{"2":{"3":1}}],["回收的的意义不大",{"2":{"13":1}}],["回收大概需要的时间",{"2":{"5":1}}],["回收对象",{"2":{"5":1,"6":1,"7":1}}],["收集器能仅从引用上就明确得知一个对象是否处于重分配集之中",{"2":{"14":1}}],["收集器仍然存在",{"2":{"12":1}}],["收集器收集的速度逐渐跟不上分配器分配的速度",{"2":{"11":1}}],["收集器在后台维护了一个优先级列表",{"2":{"10":1}}],["收集器的停顿预测模型是以",{"2":{"10":1}}],["收集器的",{"2":{"8":1}}],["收集器的垃圾收集分为三种",{"2":{"4":1}}],["收集器会计算下现在",{"2":{"5":1}}],["并且通过拷贝这些原型创建新的对象",{"2":{"26":1}}],["并同时修正更新该引用的值",{"2":{"14":1}}],["并为重分配集中的每个",{"2":{"14":1}}],["并发重映射",{"2":{"14":2}}],["并发重分配",{"2":{"14":2}}],["并发预备重分配",{"2":{"14":2}}],["并发标记是遍历对象图做可达性分析的阶段",{"2":{"14":1}}],["并发标记",{"2":{"8":1,"14":2}}],["并记录下gc",{"2":{"8":1}}],["并不是说现有的",{"2":{"5":1}}],["并将原始数组中的所有元素复制到新数组中",{"2":{"1":1}}],["新增了两个参数",{"2":{"12":1}}],["新生代内存最大空间",{"2":{"13":1}}],["新生代内存初始空间",{"2":{"13":1}}],["新生代",{"2":{"12":2}}],["新生代+部分老年代",{"2":{"6":1}}],["新生代的",{"2":{"5":1}}],["新的容量",{"2":{"1":1}}],["和",{"2":{"4":1,"12":2,"15":1}}],["和减半后的值相加",{"2":{"1":1}}],["将一个复杂对象的构建与它的表示分离",{"2":{"24":1}}],["将这些",{"2":{"14":1}}],["将会存放在",{"2":{"3":1}}],["将原始数组中的所有元素复制到新数组中",{"2":{"1":1}}],["容量大小的超级大对象",{"2":{"3":1}}],["专门用来存储大小超过region大小的",{"2":{"3":1}}],["humongous",{"2":{"3":2}}],["hugecapacity",{"2":{"1":2}}],["或者老年代空间",{"2":{"3":1}}],["空间",{"2":{"3":1}}],["扮演新生代的",{"2":{"3":1}}],["每次回收都会扫描所有的",{"2":{"14":1}}],["每次据允许的停顿时间",{"2":{"10":1}}],["每个区域记忆集里的脏卡数量等",{"2":{"10":1}}],["每一个",{"2":{"3":1}}],["每当进行这样的结构修改时",{"2":{"0":1}}],["次幂",{"2":{"3":1}}],["n",{"2":{"3":2}}],["new",{"2":{"1":2}}],["newcapacity",{"2":{"1":8}}],["取值范围是",{"2":{"3":1}}],["xmx",{"2":{"12":1}}],["xms",{"2":{"12":1}}],["xx",{"2":{"3":1,"5":2,"6":1,"10":1,"12":1,"13":11}}],["x3c",{"2":{"1":4}}],["把连续的",{"2":{"3":1}}],["关于",{"0":{"3":1}}],["作为默认的垃圾收集器",{"2":{"2":1}}],["9",{"2":{"2":1}}],["7",{"2":{"2":1}}],["js",{"2":{"15":3}}],["jdk10",{"2":{"7":1}}],["jdk",{"2":{"2":2}}],["javaint",{"2":{"1":1}}],["java",{"2":{"1":1,"3":1}}],["它也是可以自愈的",{"2":{"14":1}}],["它从",{"2":{"2":1}}],["它帮助开发人员在多线程环境下快速发现并发修改问题",{"2":{"0":1}}],["quot",{"2":{"2":2,"14":3}}],["官方称之为",{"2":{"2":1}}],["器",{"2":{"2":1}}],["按收益动态确定回收集",{"2":{"9":1}}],["按收益动态确定回收集的多线程并发收集",{"2":{"2":1}}],["按照一定的策略",{"2":{"1":1}}],["基于",{"2":{"2":1}}],["figure",{"2":{"27":1}}],["first",{"2":{"2":1,"10":1}}],["forward",{"2":{"14":1}}],["for",{"2":{"14":1}}],["fullscreen",{"2":{"27":2}}],["fullgc",{"0":{"7":1}}],["full",{"2":{"6":1,"11":1}}],["fuiigc",{"2":{"4":1}}],["factory",{"2":{"23":1,"25":1}}],["fast",{"2":{"0":1}}],["fail",{"2":{"0":1}}],["介绍",{"0":{"2":1}}],["然后立即根据region",{"2":{"14":1}}],["然后把决定回收的那一部分",{"2":{"8":1}}],["然后",{"2":{"1":1}}],["右移一位得到",{"2":{"1":1}}],["例如",{"2":{"1":1}}],["例如添加或删除元素",{"2":{"0":1}}],["20",{"2":{"11":1}}],["200",{"2":{"10":1,"11":1}}],["2048个",{"2":{"3":1}}],["2",{"2":{"1":2,"3":1}}],["除以",{"2":{"1":1}}],["表示将",{"2":{"1":1}}],["glob",{"2":{"15":2}}],["g",{"2":{"15":2}}],["gc过程",{"0":{"8":1}}],["gc",{"2":{"5":2,"6":1,"8":2,"11":1}}],["garbage",{"2":{"2":1}}],["g1不同的是",{"2":{"14":1}}],["g1一样",{"2":{"14":1}}],["g1mixedgccounttarget",{"2":{"13":1}}],["g1mixedgclivethresholdpercent",{"2":{"13":1}}],["g1maxnewsizepercent",{"2":{"12":2,"13":1}}],["g1newsizepercent",{"2":{"13":1}}],["g1newsizepercent为5",{"2":{"12":1}}],["g1newsizepercent和",{"2":{"12":1}}],["g1收集器的回收集",{"2":{"14":1}}],["g1收集器的空间分配",{"0":{"12":1}}],["g1收集器会记录每个区域的回收耗时",{"2":{"10":1}}],["g1收集器最大的优势就是",{"2":{"10":1}}],["g1heapregionsize",{"2":{"3":1,"13":1}}],["g1",{"0":{"3":1},"2":{"2":1,"4":1,"5":2,"8":1,"9":1,"10":2,"11":1,"12":2,"14":2}}],["gt",{"2":{"1":8}}],["grow",{"2":{"1":4}}],["其依赖关系是通过接口或抽象类产生的",{"2":{"19":1}}],["其中",{"2":{"1":1}}],["其长度为新的容量",{"2":{"1":1}}],["vpd",{"2":{"27":2}}],["value",{"2":{"1":1}}],["void",{"2":{"1":1}}],[">",{"2":{"1":1,"27":1}}],[">>",{"2":{"1":2}}],["table",{"2":{"14":1}}],["targetsurvivorratio",{"2":{"13":1}}],["throw",{"2":{"1":2}}],["true",{"2":{"1":1}}],["0",{"2":{"1":4}}],["校验容量是否够",{"2":{"1":1}}],["扩容至原来的1",{"2":{"1":1}}],["获取elementdata数组的内存空间长度",{"2":{"1":1}}],["of",{"2":{"21":1}}],["outofmemoryerror",{"2":{"1":2}}],["oldcapacity",{"2":{"1":16}}],["overflow",{"2":{"1":3}}],["object",{"2":{"1":3}}],["method使一个类的实例化延迟到其子类",{"2":{"25":1}}],["m1",{"2":{"14":1}}],["m0",{"2":{"14":1}}],["min",{"2":{"15":6}}],["mincapacity",{"2":{"1":11}}],["mixedgc",{"0":{"6":1},"2":{"4":1,"7":1,"13":1}}],["mb",{"2":{"3":1}}],["marking",{"2":{"8":1}}],["mark",{"2":{"8":1,"14":1}}],["maxtenuringthreshold",{"2":{"13":1}}],["maxgcpausemillis",{"2":{"13":1}}],["maxgcpausemills",{"2":{"5":2}}],["maxgcpausemilis",{"2":{"10":1}}],["max",{"2":{"1":5}}],["math",{"2":{"1":1}}],["modcount++",{"2":{"1":1}}],["modcount",{"0":{"0":1},"2":{"0":6}}],["+useg1gc",{"2":{"13":1}}],["+",{"2":{"1":7,"6":1}}],["=",{"2":{"1":9}}],["==",{"2":{"1":2}}],["isfullscreen",{"2":{"27":1}}],["initiatingheapoccupancypercent",{"2":{"13":1}}],["initial",{"2":{"8":1}}],["integer",{"2":{"1":1}}],["int",{"2":{"1":8}}],["if",{"2":{"1":5,"27":1}}],["shrg",{"2":{"15":2}}],["set",{"2":{"14":2}}],["survivor区域里的一批对象",{"2":{"13":1}}],["survivor区的填充容量",{"2":{"13":1}}],["survivorratio",{"2":{"12":1}}],["survivor",{"2":{"12":1}}],["survivor空间",{"2":{"3":1}}],["stab",{"2":{"8":1}}],["static",{"2":{"1":1}}],["stw",{"2":{"8":4}}],["s",{"2":{"1":4}}],["size",{"2":{"1":7}}],["principle",{"2":{"21":1}}],["private",{"2":{"1":5}}],["prepare",{"2":{"14":1}}],["parallelgcthreads",{"2":{"13":1}}],["public",{"2":{"1":1}}],["修改次数+1",{"2":{"1":1}}],["eden区",{"2":{"5":2}}],["eden区放满了就会马上触发",{"2":{"5":1}}],["eden",{"2":{"3":1,"12":1}}],["empty",{"2":{"1":1}}],["elementdata",{"2":{"1":10}}],["e",{"2":{"1":6}}],["abstract",{"2":{"23":1}}],["array",{"2":{"1":3}}],["arrays",{"2":{"1":1}}],["arraylist",{"2":{"0":7,"1":12}}],["add",{"2":{"1":3,"27":1}}],["boolean",{"2":{"1":1}}],["因为即使是旧引用",{"2":{"14":1}}],["因为这里的操作涉及存活对象的移动",{"2":{"8":1}}],["因为在扩容时需要进行数组复制操作",{"2":{"1":1}}],["因此",{"2":{"1":1,"14":1}}],["提供一个接口以创建一系列相关或相互依赖的对象",{"2":{"23":1}}],["提供了更好的并发安全性和一致性保证",{"2":{"0":1}}],["提高性能和效率",{"2":{"1":2}}],["以上的对象都放入老年代",{"2":{"13":1}}],["以平衡内存使用和性能",{"2":{"1":1}}],["以减少扩容次数",{"2":{"1":1}}],["以适应不断增长的元素数量",{"2":{"1":1}}],["以容纳更多的元素",{"2":{"1":1}}],["丢弃原始数组",{"2":{"1":1}}],["更新",{"2":{"1":1}}],["创建一个新的数组",{"2":{"1":1}}],["倍",{"2":{"1":1}}],["50",{"2":{"3":1}}],["5倍",{"2":{"1":1}}],["5",{"2":{"1":4,"3":1,"12":1,"13":1}}],["1mb~32mb",{"2":{"13":1}}],["1~32",{"2":{"3":1}}],["15",{"2":{"1":1}}],["100~300",{"2":{"11":1}}],["100",{"2":{"11":1}}],["10",{"2":{"1":3}}],["1",{"2":{"1":9,"12":2}}],["会将当前容量增加一半",{"2":{"1":1}}],["会创建一个新的更大的数组",{"2":{"1":1}}],["通过按比例增加容量",{"2":{"1":1}}],["通过计算",{"2":{"1":1}}],["通过这种扩容机制",{"2":{"1":1}}],["通过使用",{"2":{"0":1}}],["通常把期望停顿时间设置为",{"2":{"11":1}}],["通常是增加一半",{"2":{"1":1}}],["通常",{"2":{"1":1}}],["classlist",{"2":{"27":2}}],["cleanup",{"2":{"8":1}}],["css",{"2":{"15":3}}],["collection",{"2":{"14":1}}],["code",{"2":{"1":1}}],["concurrent",{"2":{"8":1,"14":4}}],["concurrentmodificationexception",{"2":{"0":1}}],["conscious",{"2":{"1":1}}],["copyof",{"2":{"1":1}}],["capacity",{"2":{"1":2}}],["即右移一位相当于除以",{"2":{"1":1}}],["即扩容为原始容量的",{"2":{"1":1}}],["即",{"2":{"1":1}}],["检查当前元素数量是否超过了内部数组的容量",{"2":{"1":1}}],["这对系统的扩展性",{"2":{"17":1}}],["这次访问将被",{"2":{"14":1}}],["这也就是它的名字garbage",{"2":{"10":1}}],["这种计算方式常用于动态数组或哈希表等数据结构的扩容操作",{"2":{"1":1}}],["这是将原始容量",{"2":{"1":1}}],["这是一j个位运算操作符",{"2":{"1":1}}],["这个阶段根据特定的查询条件统计出本次收集过程要清理哪些region",{"2":{"14":1}}],["这个过程要把重分配集中的存活对象复制到新的",{"2":{"14":1}}],["这个过程是非常耗时的",{"2":{"7":1}}],["这个过程称为动态扩容",{"2":{"1":1}}],["这个计算公式可以在需要扩容的情况下",{"2":{"1":1}}],["这个操作可以有效地将原始容量减半j",{"2":{"1":1}}],["这行代码是用于计算新容量的表达式",{"2":{"1":1}}],["这样就节省了一次遍历的开销",{"2":{"14":1}}],["这样可以让系统不至于单次停顿时间过长",{"2":{"13":1}}],["这样可以减少频繁的扩容操作",{"2":{"1":1}}],["这样",{"2":{"1":1}}],["就会触发一次",{"2":{"6":1}}],["就会触发扩容机制",{"2":{"1":1}}],["就有了更多的空间来存储新的元素",{"2":{"1":1}}],["就意味着在迭代过程中有其他线程对",{"2":{"0":1}}],["如果接口的单一职责做得好",{"2":{"17":1}}],["如果用户线程此时并发访问了位于重分配集中的对象",{"2":{"14":1}}],["如果超过这个值",{"2":{"13":1}}],["如果回收时间远远小于参数",{"2":{"5":1}}],["如果",{"2":{"1":1}}],["如果当前容量已满了",{"2":{"1":1}}],["如果当前元素数量已经达到容量上限",{"2":{"1":1}}],["如果当前元素数量已经达到了内部数组的容量上限",{"2":{"1":1}}],["如果在迭代过程中发现",{"2":{"0":1}}],["添加元素时",{"2":{"1":1}}],["当添加元素时",{"2":{"1":1}}],["当",{"2":{"1":1}}],["当使用迭代器遍历",{"2":{"0":1}}],["避免潜在的错误",{"2":{"0":1}}],["异常",{"2":{"0":1}}],["违反了预期的并发安全性",{"2":{"0":1}}],["进行了结构修改",{"2":{"0":1}}],["进行结构修改的次数",{"2":{"0":1}}],["值",{"2":{"0":1}}],["时",{"2":{"0":1}}],["的并发重映射并不是一个必须要",{"2":{"14":1}}],["的这种行为称作指针的",{"2":{"14":1}}],["的目的并非为了像",{"2":{"14":1}}],["的标记是在指针上而不是在对象上进行的",{"2":{"14":1}}],["的短暂停顿",{"2":{"14":1}}],["的名字不叫这些",{"2":{"14":1}}],["的初始标记",{"2":{"14":1}}],["的空间是怎么划分的呢",{"2":{"12":1}}],["的概念",{"2":{"12":1}}],["的由来",{"2":{"10":1}}],["的全部空间",{"2":{"8":1}}],["的存活对象复制到空的",{"2":{"8":1}}],["的回收价值和成本进行排序",{"2":{"8":1}}],["的记录",{"2":{"8":1}}],["的对象",{"2":{"3":1}}],["的",{"2":{"3":1}}],["的大小可以通过参数",{"2":{"3":1}}],["的内存布局",{"0":{"3":1},"2":{"2":1,"9":2}}],["的内部数组引用为新数组",{"2":{"1":1}}],["的结果为",{"2":{"1":1}}],["的整数除法",{"2":{"1":1}}],["的二进制表示向右移动一位",{"2":{"1":1}}],["的扩容机制会带来一定的开销",{"2":{"1":1}}],["的扩容机制大致遵循以下步骤",{"2":{"1":1}}],["的扩容机制是在容量不足时自动增加其内部数组的大小",{"2":{"1":1}}],["的值为",{"2":{"1":2}}],["的值与初始记录的值不同",{"2":{"0":1}}],["的值都会自增",{"2":{"0":1}}],["的主要作用是用于支持快速失败机制",{"2":{"0":1}}],["结构修改是指会改变",{"2":{"0":1}}],["中介者",{"0":{"32":1}}],["中的存活对象低于这个值时才会回收该",{"2":{"13":1}}],["中存活的对象拷贝到别的region里去",{"2":{"6":1}}],["中还有一类特殊的",{"2":{"3":1}}],["中断遍历过程",{"2":{"0":1}}],["中",{"2":{"0":1,"1":1,"8":1,"12":1}}],["在最后一个筛选回收阶段可以回收一会然后暂停回收",{"2":{"13":1}}],["在一次回收过程中指定做几次筛选回收",{"2":{"13":1}}],["在垃圾收集过程中",{"2":{"10":1}}],["在满足gc停顿时间要求的同时",{"2":{"2":1}}],["在预知需要存储大量元素的情况下",{"2":{"1":1}}],["在",{"2":{"0":1,"12":1}}],["类中的一个字段",{"2":{"0":1}}],["是一款可以指定最大停顿时间",{"2":{"2":1}}],["是原始容量的值",{"2":{"1":1}}],["是否等于",{"2":{"1":1}}],["是",{"2":{"0":1}}]],"serializationVersion":2}';export{t as default};
