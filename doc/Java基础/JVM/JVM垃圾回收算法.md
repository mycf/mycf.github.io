

## 判断一个对象是否可被回收

### 引用计数算法

### 可达性分析算法

Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象



### 方法区的回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。

主要是对常量池的回收和对类的卸载。

在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。

类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:

- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。



### finalize()

finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。

当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。

### 对象的创建

1. 类加载
2. 分配内存
3. 对象设置
4. 对象初始化，执行构造函数



#### 对象的访问定位

使用句柄和**直接指针**两种：

- 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

- 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销

使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。



当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程

![image-20231124205353008](https://gitee.com/ycfan/images/raw/master/img/image-20231124205353008.png)



首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程

运行时通过-Xms20M、-Xmx20M、-Xmn10M这三个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。-XX：Survivor-Ratio=8决定了新生代中Eden区与一个Survivor区的空间比例是8∶1，从输出的结果也清晰地看到“eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量）。



- 白色： 表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色： 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色： 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

如果用户线程与收集器是并发工作呢？收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果。一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。另一种是把原本存活的对象错误标记为已消亡

当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：
- 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）

增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。



![image-20231124213526535](https://gitee.com/ycfan/images/raw/master/img/image-20231124213526535.png)


### Garbage First收集器
Garbage First（简称G1）

G1垃圾回收器的要点如下：

- G1是从JDK 9开始作为默认垃圾回收器。
- G1具有优秀的综合能力，可以兼顾响应时间和吞吐量。
- G1将整个堆内存划分为多个大小相等的区域（称为region），包括伊甸园区、幸存区、老年代以及用于存储大对象的Humongous区域。
- G1使用标记复制算法，并对大对象进行特殊处理。



G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。



G1的工作流程可以分为三个阶段：新生代内存回收、并发标记阶段和混合收集阶段。

- 在新生代内存回收阶段，创建对象时空闲区域被选择作为伊甸园区，当伊甸园区满时触发新生代的垃圾回收。

- 并发标记阶段使用标记复制算法标记存活对象，并将幸存对象复制到幸存区域。

- 混合收集阶段包括新生代的内存释放和部分老年代区域的内存释放，通过多次混合收集逐步释放剩余老年代的内存。

- G1会自动调整新生代的大小，并根据需要触发垃圾回收。

- 垃圾回收过程中的标记和复制操作会暂停用户线程，但由于幸存对象较少，暂停时间相对较短。

#### 新生代内存回收

 刚开始这些区域都是空闲的, 当我们创建对象的时候， 就会挑出一些空闲区域, 作为Eden空间，那随着对象越来越多, 那这些Eden区可能都要放满了, 放满了它就会触发一个啊, 第一次新生代的垃圾回收啊, 就是这里的d这个三标注的新生代的垃圾回收, 那有同学说, 那你为啥不多创建几个电源啊, 注意, Eden大小, 它是会受到整个新生代的限制的, 在G1里啊, 新生代的内存占比它是不固定的, 它是在5%到60%之间波动啊, G1会自动来调整, 那么他就会触发Egen的垃圾回收, 采用的标记复制的算法, 也就是沿着跟对象的GC Root, 加标记, 标记好的,留下来,没标记的就可以当成垃圾了,他会把这些幸存对象, 用复制的算法复制到这个Survivor区中去, 当然这个标记的过程以及复制的过程, 都需要暂停用户线程, 都会触发stop the world, 不过还好啊, 因为我们的幸存对象比较少, 所以这个暂停时间呢也会相对比较短, 好当我们的幸存对象复制到幸存区之后呢, 这些伊甸园区域占用内存就可以释放掉了, 好这就是一次新生代的回收啊, 

我们再看一个，随着时间的流逝啊, 那我们的新生代内存也是又会被分配给伊甸园, 区里面又存了很多这个新的对象啊, 这些对象都是诞生在伊甸园嘛, 好接下来这些一点g的内存又逐渐耗尽了啊, 又不够用了, 不够用了, 它就会把伊甸园中的幸存对象, 和这个上一次survival幸存区的幸存对象, 它们合在一起, 复制到一个新的幸存区啊, 当然如果这个幸存区中有一些对象, 也就是一部分对象啊, 由于经过了很多, 熬过了很多次垃圾回收啊, 那另一部分另一部分幸存对象, 以及伊甸园中的幸存对象, 就会复制到一个新的幸存群, 那这样一来呢, 这些伊甸园和上一次的幸存区, 它们的内存就可以释放掉了, 好这也是一次新生代的垃圾回收好, 这是我们的第一个阶段啊

#### 并发标记阶段

**触发条件**, 默认老年代的内存占比, 达到了整个堆内存的, 45%以上的时候啊, 它就会触发并发标记

G1 在老年代中查找存活对象并对其进行标记，这个过程是并发执行的，不会暂停用户线程。为了解决漏标问题，G1 使用了原始快照法来检测漏标对象。然后，在重新标记阶段，需要处理漏标对象，这就需要停止用户线程，进行全局的标记。

#### 混合收集阶段

为了控制暂停时间，G1 不会一次性回收所有老年代的内存。它会选择回收价值较高的老年代，即存活对象较少的老年代。这些老年代以及当前的伊甸园和幸存区会被一起回收。在混合收集中，幸存对象会被复制到新的幸存区，从而释放内存。

混合收集可能需要多次执行，以逐步释放剩余老年代的内存。在多次混合收集之后，会再次回到新生代的垃圾回收阶段，并重复执行这些步骤。

在新生代回收、并发标记和混合收集这三个阶段中，由于许多操作是并发执行的，因此对用户暂停的时间相对较短。

在某些情况下，可能会发生并发失败，即回收速度无法跟上新对象的分配速度。在这种情况下，G1 将退回到一种保守的回退策略 Full GC。

#### Full GC



G1可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。


- 初始标记 （Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
- 并发标记 （Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
- 最终标记 （Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
- 筛选回收 （Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。


