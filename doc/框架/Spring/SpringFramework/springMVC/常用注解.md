[有趣](https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/pt01.html) 

@EnableAspectJAutoProxy

@RequestMapping
@RequsetBody
@ResponseBody

完整的要点提取
零基础学it月薪过万就来黑马程序员, 黑马程序员成就it黑马, 接下来我们介绍一些跟spr mc相关的注解, 先看第一组mapping, 也就是跟路径映射相关的重点, 这里面啊看着很多, 但实际上核心的只有一个, 就是这里的request map, 它的作用啊, 就是建立我们请求路径, 跟控制器方法之间的这种映射关系, 将来一个请求过来以后啊, 他就会根据这个请求路径, 与我们request mapping中的路径进行匹配, 匹配上了, 他就知道, 接下来呢应该由标注了request mapping注解的方法, 来处理这个请求, 好这是它的最重要的用法, 当然呢这个request spin也可以加在类上, 加在类上呢, 就是当你一个类中有多个控制器方法, 它们有一个相同的路径前缀时, 那我们可以把这个相同的路径前缀, 给它提取出来, 放在类上的request map里啊, 这是它的第二个作用好, 至于剩下的这些注解呢, 他们都可以看成是request mapping的一个派生注解, 比如说我们以其中的get map为例, 我们看一下它的源码啊, 在这里有啊, 这个get白屏, 大家看它是怎么实现的呢, 唉它上面又加了request map, 就说明它跟request map啊其实功能是相同的, 你看从它里面的这些属性上也可以看出来啊, 它的name就相当于是request mapping的, 他的value就相当于是request bing value啊, 因为呢他用这个alias for啊, 建立了这种关系啊, 就是表示它是一个别名啊, 它俩的功能是一样的, 只是不同之处在于哪呢, 不同之处在于我们get map限制了它的mea, 只能是get请求啊, 它不会去匹配和处理其他的请求啊, 什么post啊, put他只认get请求好, 这是它的一个限制啊, 除此以外呢其他的都一样好, 那一个学会了, 那剩下的我相信大家就类似了啊, 除了这个get map以外, 我们看个post麦片是不是一样呀, 只不过他说啊这回的请求方式只能是post请求好, 所以这一组注解我们就介绍完了, 下面的都是request mapping的派生注解, 好我们再来看下一组, 下一组是跟rest相关的一些注解, 这里重要的有这么三个啊, 一个是re request body, 这个呢就是处理请求体中的jason数据的啊, 把jason数据呢转换成java的对象, response body作用就跟他恰好相反, 他是把放控制器方法返回的java对象, 转换成json数据, 然后写入到响应体啊, 一个是处理请求体, 一个是处理响应题, 好至于这个啊, response status啊, 它是可以控制响应的状态吗, 那么因为我们rest风格啊, 他推荐使用这种jason数据, 来作为这个数据的交换格式, 因此呢我们这里几个注解啊, 他们主要都是处理这种jason数据的, 所以我们把它归类到一起了, 那最后这个rest control它是一个组合注解, 它实际上是我们control跟这个response body的组合啊, 大家可以看到rest controler上既标注了controller, 也标注了response body, 也就是你将来把这个rest control标注在类上, 相当于就标注了上面这两个注解啊, 也就是将来rise control标注类既是一个控制器, 也相当于同时加了response body, response body加在类上, 就意味着你这个类中所有控制器方法的返回值, 都会被转换成jason写入到响应体啊, 就相当于是一种便捷写法, 好这是关于rest相关的几个注解, 好我们再来看下一组统一处理, 统一处理, 这里我们涉及到了一个control west啊, 这个大家也都用过, 就是可以把一些, 比如说你想做这个统一处理的异常方法, 还有这个转换器啊, 转换器方法, 还有这个mathattribute的方法, 都可以放在这个add control advice标注的内容啊, 已达到一个统一的处理目的啊, 当然了, 我们最常用的就是把一些处理异常的方法, 放在这个control vs中来实现一个异常的统一处理, 那怎么处理异常呢, 我们可以把一个方法上标注这个exception, handler啊, 就表示这个标注了exception handler的方法, 它是专门来处理异常的方法, 当然了啊, 他俩结合使用比较多啊, 当然这个exception handle了, 它标注的方法不一定非要放在这个control advice那种, 你也可以把它放在普通的控制器中, 放在一个单独的控制系统, 就相当于是一个局部的这个异常处理, 如果呢你把它放在这个标注了control os的一种, 就相当于是一个全局的异常处理, 好最下面这个rest controlled advice, 它也是一个组合注解啊, 它就相当于组合了control advice跟这个response body, 我们可以看一下, 那就相当于在我们control vs里, 如果你做了异常处理, 将来要返回的结果也会被转换成jason数据, 然后写到响应体里啊, 就这个作用好了, 跟这个统一处理相关的几个注解我们也看完了, 接下来呢就是看请求中的一些参数信息, 我们怎么获取获取参数信息啊
它的途径可能是多种多样的, 那一种途径呢, 我们就是通过这个标注request header, 去获取请求头中的参数信息, 还有呢标注这个cookie value啊, 去获取cookie的值, 然后用这个pass variable, 去获取请求路径中的参数值, request paraa是获取真正的这种请求, 参数的参数值啊, 也就是那个问号后面的键值信息啊, 当然也可以是表单中的这个请求参数好, 后两种呢用的不多, 我就不啰嗦了, 这里呢其实用的最多的, 或者说相对最重要的还是这个pass val, 这个request pam呢用的比较少啊, 因为只要你的请求参数跟方法参数名称啊, 能对得上, 它, 就可以省略这个request bl, request b, 主要的一个作用就是它可以设置那个默认值, 它里面有个default value属性可以设置, 如果你没有传这个参数时, 没有传递这个请求参数时, 你可以给他设一个默认值, 啊在这里啊, 这个是我觉得它最重要的最有用的一个地方, 好了, 关于这个参数的几个相关注解, 我们也说到这了, 下面几个转换和格式化, 这个用的就不多了, 我们稍微过一下吧, data time format转换日期和时间格式的, number format转换数字格式的啊, unit bender是注册一些自定义的类型转换器的, validation就是做这个bean的校验的, 其实真正做校验的那些注解, 也不是spring中的注解啊, 那我们这个validated啊, 只是加在加在这个一个java bean上, 表示这个java bean将来要做数据校验, 至于那些校验规则呢, 都是加在这病的那个属性上啊, 他是介入了一个第三方的注解, 比如说什么not empty啊, not n啊等等啊, 那些注解才去完成真正的校验规则, validated只是作为一个算是一个校验的入口啊, scope scope这边呢啊咱们都能说的上来, 什么应用程序作用域啊, request作用域啊, 就是把标注了这些注解的类啊, 他们可以在spring容器里面控制他们的作用, 但是实际上用的非常少啊, 大家一般都不怎么用, 所以这个咱们知道就可以了, 包括下面几个什么model attribute, request psession h, 这个大家用的也非常少啊, 因为涉及到这种用注解去维护状态, 都不太好用啊, 容易用错, 所以用的非常少, 我们就过了啊, 最后一组ajax ajs相关的一个注解呢叫cross orge, 作用呢是解决ajx请求的一个跨域问题, 它的原理啊就是往响应头上加一些特殊的头, 允许你这个aj x跨越这种请求, 当然了, 如果你用的是hd client这样的客户端了, 它是没有这种跨域问题啊, 他只是用在java script里面使用ajax啊, 访问时他才出会存在这个跨域问题啊, 所以它的使用场景大家也要知道好了, 关于spring mc的几个相关重要注解啊, 我就给大家总结到这
