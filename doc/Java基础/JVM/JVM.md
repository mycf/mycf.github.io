 [AbstractQueuedSynchronizer.md](../AbstractQueuedSynchronizer.md)

# synchronize 和retreenlock分别实现原理

在Java并发编程中，`synchronized`和`ReentrantLock`是两种主流的锁机制，它们的实现原理和性能表现有显著差异。以下是它们的实现原理对比及效率分析：

---

### **一、`synchronized`的实现原理**
#### **底层机制**

1. **JVM内置锁**  
   `synchronized`是Java语言原生的关键字，由JVM直接支持，通过**对象头中的Mark Word**实现锁状态管理。每个对象都有一个关联的**Monitor（监视器锁）**。
   
2. **锁升级过程**  
   • **偏向锁（Biased Locking）**  
     单线程无竞争时，直接通过CAS标记线程ID，无需实际锁操作。
   • **轻量级锁（Lightweight Locking）**  
     多线程轻度竞争时，通过自旋（CAS）尝试获取锁，避免线程阻塞。
   • **重量级锁（Heavyweight Locking）**  
     竞争激烈时，升级为操作系统层面的**互斥量（Mutex）**，线程进入阻塞队列。

3. **锁的释放**  
   退出同步代码块时，JVM自动释放锁，无需手动干预。

#### **特点**
• **自动管理锁**：无需显式加锁/解锁，避免遗漏。
• **非公平锁**：默认抢占式获取锁，无排队机制。
• **不可中断**：线程阻塞后无法被中断。

---

### **二、`ReentrantLock`的实现原理**
#### **底层机制**
1. **基于AQS（AbstractQueuedSynchronizer）**  
   `ReentrantLock`通过AQS维护一个**双向链表队列（CLH队列）**管理等待线程，实现锁的获取与释放。

2. **公平性支持**  
   • **非公平锁（默认）**：直接尝试抢占锁，失败后进入队列等待。
   • **公平锁**：按线程请求顺序排队，严格FIFO。

3. **显式锁操作**  
   • 必须手动调用`lock()`和`unlock()`，通常结合`try-finally`确保释放。

4. **高级功能**  
   • **可中断**：`lockInterruptibly()`允许响应中断。
   • **超时机制**：`tryLock(long timeout, TimeUnit unit)`。
   • **条件变量**：`Condition`对象支持复杂线程协作。

#### **特点**
• **灵活性**：支持公平锁、可中断、超时等特性。
• **手动管理**：需显式释放锁，编码要求更严格。

---

### **三、性能对比**
#### **1. 低竞争场景**
• `synchronized`更高效：  
  偏向锁和轻量级锁通过CAS快速获取锁，几乎无额外开销。
• `ReentrantLock`略慢：  
  非公平锁需要CAS操作，但无锁升级过程，总体与`synchronized`接近。

#### **2. 高竞争场景**
• `synchronized`可能更差：  
  升级到重量级锁后依赖操作系统互斥量，线程切换开销大。
• `ReentrantLock`更优：  
  通过AQS自旋和队列管理减少上下文切换，吞吐量更高（尤其在非公平模式下）。

#### **3. 公平性需求**
• `synchronized`仅支持非公平锁。
• `ReentrantLock`公平锁严格按顺序执行，但性能显著低于非公平锁。

---

### **四、适用场景**
| **场景**                   | **推荐选择**    | **理由**                                 |
| -------------------------- | --------------- | ---------------------------------------- |
| 简单同步需求               | `synchronized`  | 代码简洁，自动管理锁，性能足够。         |
| 需要可中断、超时或条件变量 | `ReentrantLock` | 支持高级功能，灵活性更高。               |
| 高并发且竞争激烈           | `ReentrantLock` | 避免重量级锁的线程切换开销，吞吐量更优。 |
| 公平锁需求                 | `ReentrantLock` | `synchronized`无法实现公平锁。           |

---

### **五、总结**

• **默认选择`synchronized`**：在大多数场景下，其性能已足够优秀且编码简单。
• **特殊需求选`ReentrantLock`**：需要公平性、可中断、超时或条件变量时使用。
• **Java版本影响**：JDK 6+对`synchronized`的优化（如锁消除、锁粗化）缩小了两者差距。

**效率结论**：  
• **低竞争时**：`synchronized`更高效。  
• **高竞争时**：`ReentrantLock`（非公平模式）更优。

# 方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

HotSpot使用永久代来实现方法区，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。



# 元空间

JDK 元空间（Metaspace）是自 Java 8 起取代永久代（PermGen）的类元数据存储区域，其核心设计目标是解决永久代的内存溢出问题和提升灵活性。元空间存储的数据类型及其特点可归纳如下：

---

### **一、元空间存储的核心内容**
1. **类元数据（Class Metadata）**  
   • **类结构信息**：包括类名、父类、接口、访问修饰符、字段（名称、类型、修饰符）、方法（名称、返回值、参数、字节码）、注解等。  
   • **Klass 对象**：类的内存表示形式（C++ 对象），通过对象头的 Klass 指针引用到元空间中的类数据。  
   • **虚方法表（vtable）和接口方法表（itable）**：用于支持多态和动态方法调用。

2. **运行时常量池（Runtime Constant Pool）的符号引用**  
   • 包括类、接口的全限定名、方法名、字段名等符号引用。  
   • **注意**：JDK 7 及以后，字符串常量池（String Constant Pool）和部分字面量已移至堆内存，但符号引用仍保留在元空间。

3. **即时编译器（JIT）产物**  
   • **JIT 编译后的本地机器码**：热点代码优化后的本地代码存储在元空间的非类空间（Non-Class Space）。  
   • **方法字节码**：未被 JIT 编译的原始方法字节码也存储于元空间。

4. **非 Java 类数据（Non-Java Class Data）**  
   • **动态生成的类**：如通过 ASM、CGLIB 生成的代理类。  
   • **模块化系统元数据**：JDK 9+ 模块化系统中模块的依赖关系和权限信息。

---

### **二、元空间与永久代的区别**

| **维度**         | **永久代（JDK 7 及之前）**                  | **元空间（JDK 8 及之后）**                                   |
| ---------------- | ------------------------------------------- | ------------------------------------------------------------ |
| **存储位置**     | 堆内存的一部分，与新生代、老年代地址连续    | 本地内存（Native Memory），独立于堆                          |
| **内存管理**     | 受 `-XX:PermSize` 和 `-XX:MaxPermSize` 限制 | 默认无上限，可通过 `-XX:MaxMetaspaceSize` 限制               |
| **垃圾回收效率** | 回收效率低，易触发 Full GC                  | 独立于堆 GC，由元空间虚拟机直接管理                          |
| **内存溢出风险** | 易因类加载过多导致 `PermGen space` OOM      | 默认无上限，但需警惕本地内存耗尽（需设置 `MaxMetaspaceSize`） |

---

### **三、元空间的优化与注意事项**
1. **动态扩展机制**  
   • 元空间初始大小由 `-XX:MetaspaceSize` 指定，实际占用超过此值时会触发 GC 并自动调整。  
   • 若未设置 `MaxMetaspaceSize`，元空间可能无限扩展直至耗尽系统内存，导致进程被强制终止。

2. **类卸载与内存释放**  
   • 类加载器及其加载的所有类不再被引用时，元空间会回收其占用的内存，但释放的内存可能不会立即返还系统，而是标记为可复用。

3. **容器化环境配置建议**  
   • 在 Docker 中需综合考虑堆内存（`-Xmx`）和元空间（`-XX:MaxMetaspaceSize`）的分配，避免因总内存超限触发 OOM Killer。

---

