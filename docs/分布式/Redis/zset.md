# 基本概念
value 赋予一个 score，代表这个 value 的排序权重。

Redis 的 zset 是一个复合结构，内部实现是一个 hash 字典加一个跳跃列表 (skiplist)。
 ==hash 结构==来存储 value 和 score 的对应关系，保证了内部value 的唯一性。
 ==[跳跃列表]==提供按照 score 来排序的功能，能够指定 score 的范围来获取 value 列表。
![[zset 2023-12-20 19.09.36.excalidraw|100%]]
## skiplist
跳跃列表就是类似于这种层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。 
「跳跃列表」内部的元素可能「身兼数职」，可以快速在不同层次之间进行「跳跃」。定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。


![[zset 2023-12-20 19.19.14.excalidraw|100%]]
Redis 的跳跃表共有 ==32 层==。每一个 kv 块对应的结构如下面的代码中的 zsnode 结构，kvheader 也是这个结构，只不过**value 字段是 null 值**--无效的，score 是Double.MIN VALUE，用来垫底的。kv 之间使用指针串起来形成了==双向链表==结构，它们是==有序排列==的，从小到大。不同的 kv 层高可能不一样，层数越高的 kv 越少。同一层的 kv会使用指针串起来。每一个层元素的遍历都是从 kv header 出发。
### 查找过程
![[zset 2023-12-20 21.01.01.excalidraw|100%]]
如图所示，我们要定位到那个橙色的 kv，需要从 header 的最高层开始遍历找到第一个节点(最后一个比[我]小的元素)，然后从这个节点开始降一层再遍历找到第二个节点 (最后一个比[我]小的元素)，然后一直降到最底层进行遍历就找到了期望的节点 (最底层的最后一个比我[小]的元素).
我们将中间经过的一系列节点称之为[搜索路径]，它是从最高层一直到最底层的每一层最后一个比[我]小的元素节点列表。
有了这个搜索路径，我们就可以插入这个新节点了。不过这个插入过程也不是特别简单。因为新插入的节点到底有多少层，得有个算法来分配一下，跳跃列表使用的是==随机算法==。

### 随机层数
对于每一个新插入的节点，都需要调用一个==随机算法给它分配一个合理的层数==。
> 直观上期望的目标是 50% 的 Level1，25% 的 Level2，12.5% 的 Level3，一直到最顶层 2^-63.因为这里每一层的晋升概率是 50%。

Redis 标准源码中的晋升概率只有 ==25%==，也就是代码中的 ZSKIPLIST_P 的值。所以官方的跳跃列表==更加的扁平化，层高相对较低，在单个层上需要遍历的节点数量会稍多一点。

# 容器型数据结构的通用规则
list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则:
1. create if not exists
如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的.
Redis 就会自动创建一个，然后再 rpush 进去新元素
2. drop if no elements如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。过期时间
Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期,而不是其中的某个子 key。
还有一人需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了set 方法修改了它，它的过期时间会消失。