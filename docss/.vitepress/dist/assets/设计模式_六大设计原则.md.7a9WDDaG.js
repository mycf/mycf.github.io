import{_ as t,C as r,c as o,o as l,j as n,ag as i,G as p}from"./chunks/framework.Bw-5EFTY.js";const b=JSON.parse('{"title":"六大设计原则","description":"","frontmatter":{},"headers":[],"relativePath":"设计模式/六大设计原则.md","filePath":"设计模式/六大设计原则.md"}'),d={name:"设计模式/六大设计原则.md"};function s(h,a,c,_,u,m){const e=r("Excalidraw");return l(),o("div",null,[n("p",null,[p(e,{"data-src":"1.excalidraw"})]),a[0]||(a[0]=i('<h1 id="六大设计原则" tabindex="-1">六大设计原则 <a class="header-anchor" href="#六大设计原则" aria-label="Permalink to &quot;六大设计原则&quot;">​</a></h1><h2 id="单一职责原则" tabindex="-1">单一职责原则 <a class="header-anchor" href="#单一职责原则" aria-label="Permalink to &quot;单一职责原则&quot;">​</a></h2><p>单一职责原则的定义是：应该有且仅有一个原因引起类的变更。</p><p>❑类的复杂性降低，实现什么职责都有清晰明确的定义；</p><p>❑可读性提高，复杂性降低，那当然可读性提高了；</p><p>❑可维护性提高，可读性提高，那当然更容易维护了；</p><p>❑变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><h2 id="里氏替换原则" tabindex="-1">里氏替换原则 <a class="header-anchor" href="#里氏替换原则" aria-label="Permalink to &quot;里氏替换原则&quot;">​</a></h2><p>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p><h2 id="依赖倒置原则" tabindex="-1">依赖倒置原则 <a class="header-anchor" href="#依赖倒置原则" aria-label="Permalink to &quot;依赖倒置原则&quot;">​</a></h2><p>❑模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p><p>❑接口或抽象类不依赖于实现类；</p><p>❑实现类依赖接口或抽象类。</p><h2 id="接口隔离原则" tabindex="-1">接口隔离原则 <a class="header-anchor" href="#接口隔离原则" aria-label="Permalink to &quot;接口隔离原则&quot;">​</a></h2><p>客户端不应该依赖它不需要的接口。</p><h2 id="迪米特法则" tabindex="-1">迪米特法则 <a class="header-anchor" href="#迪米特法则" aria-label="Permalink to &quot;迪米特法则&quot;">​</a></h2><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）</p><p>一个类应该对自己需要耦合或调用的类知道得最少。</p><h2 id="开闭原则" tabindex="-1">开闭原则 <a class="header-anchor" href="#开闭原则" aria-label="Permalink to &quot;开闭原则&quot;">​</a></h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>',20))])}const q=t(d,[["render",s]]);export{b as __pageData,q as default};
