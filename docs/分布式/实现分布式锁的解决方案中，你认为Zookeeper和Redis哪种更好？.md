#面试 
#  为什么使用分布式锁

目前常使用redis和zookeeper实现分布式锁。

# Redis可以通过两种方式实现分布式锁：
第一种是基于Redis本身提供的setnx指令，setnx设置key时，如果key已存在会返回0，表示无法设置，否则返回1，表示设置成功。通过这种机制去判断是否获得锁
第二种是基于redisson，redisson提供了分布式锁的封装方法，只需要调用api就行了。redisson里面的指令都是通过lua脚本实现的，lua脚本可以保证脚本执行的原子性。另外，redisson还提供了watchdog，翻译过来就是看门狗，它会在获取锁之后，每隔10秒钟把key的时间续约，从而避免锁的过期。

# zookeeper实现分布式锁：
通过临时有序节点实现，线程去zookeeper

Redis获取锁简单粗暴，如果取不到锁，就会不断尝试，这里会占用cpu资源，对整个应用程序造成很大影响
Redis是AP的模型，也就是可用性模型，在集群模式中，很容易存在数据一致性，导致锁出现问题，即便使用 `Redlock` 算法来实现分布式锁，但是在某些复杂场景下，也无法保证锁的100%可用。不过在实际开发中使用 Redis 实现分布式锁还是比较常见的，因为大部分的情况下，都不会遇到一些极端复杂的场景；更重要的一个点是Redis的性能是比较高的，所以在高并发场景中，比较合适一点。

Zookeeper 天生的设计定位就是一个分布式协调组件，是CP模型，所以它更适合用来实现分布式锁。Zookeeper如果获取不到锁，只需要添加一个监听器就行了，不用一直去轮询，所以性能消耗小一点。
如果在两者之间做选择的话，比较推荐zk实现分布式锁。因为分布式锁来说，是一个CP模型的场景，而Redis是AP模型的场景，所以Zookeeper更加适合一点。
  

|     |     |     |
| --- | --- | --- |
|     |     |     |
|     |     |     |
|     |     |     |
![[分布式锁 2023-12-26 12.53.41.excalidraw]]




使用分布式锁的一个核心目的是为了解决在同一个时刻，多个进程或者多个线程去访问某个共享资源所带来的安全性问题。
而根据锁的用途，可以分为两类：
第一类是共享锁，就是在同一时刻允许多个进程或者线程去访问某个共享资源，可以适用幂等性的场景中，从而避免重复加锁带来的性能开销。
第二类是排它锁，在同一个时刻只允许一个线程或者进程访问共享资源，适合在非幂等性的场景中。