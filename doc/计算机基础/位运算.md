## 计算机中的数值表示

计算机以二进制表示数据，以表示电路中的正反。在二进制下，一个位只有0和1。逢二进一位。类似十进制下，一个位只有0~9。逢十进一位。

```js
101//5的二进制
 11//3的二进制
```

计算机中存储数据，以字节为单位，一个字节有8个位，即可以表示-128~127范围的数字。上述的二进制的完整表示为：

```js
00000101//5的二进制
00000011//3的二进制
```

二进制的最高位0代表数值为非负数，1代表数值为负数，负数在下文提及，此处不赘述

## 逻辑运算：与、或、非

二进制有三种逻辑运算，也是为了便于二进制之间进行运算

### & 与

运算符号为&，运算规律是：真真为真，真假为假，假假为假

```js
1&1//1
1&0//0
0&0//0
```

### | 或

运算符号为|，运算规律是：真真为真，真假为真，假假为假

```js
1 | 1 //1
1 | 0 //1
0 | 0 //0
```

### ~ 非

运算符为~，取反的逻辑，运算规律：二进制位若为1，取反后为0。若为0，取反后为1

```js
~1 //~00000001 =>11111110//代表-2 
```

### 异或 ^


## 正数、负数的表示

对于负数的表示，比较特殊，其有一条运算规律：对非负数的二进制进行取反、然后+1，便可得其负数的二进制表示，以3为例子：

```js
   00000011//3的二进制
//~00000011 对3进行取反，得到结果A
   11111100
//对结果A进行+1
   11111101//-3在计算机中的最终表示，给计算机看的，不是给人看的，
```

最终得出在一个字节下，11111101表示-3

## 加减法运算过程

计算机是用来计算的，那么必须支持最基本的加减法，这里以5和3的加减法为例：

### 加法 +

类似十进制的进位方式，二进制逢二进一
 5+3
```js
   00000101 //5的二进制
+  00000011 //3的二进制
=  00001000 //8的二进制
```

### 减法 -

对于5-3，可以看成 5+(-3)，那么变相成加法运算了，然后按照加法的规则进行

```js
   00000101//5的二进制
+  11111101//-3的二进制
= 100000010//258的二进制
```

5+-3=258，看起来显然不正确，这里已经超过了一个字节的表示范围-128~127，溢出的部分会被忽略掉。

```js
1 00000010//超出的1部分，会被去掉，变成如下
  00000010//2
```

利用溢出，就是可以实现减法的运算了：

```js
   00000101//5的二进制
+  11111101//-3的二进制
=  00000010//2的二进制
```

## 将32位的int，转成31个布尔值

在java中，一个字节，也就是8位，而布尔值在java中至少占用一个字节（关于布尔值具体占几个字节，不在此处讨论），如果用户有7个属性，如是否为汉族、是否为男性等，如果全用布尔值来表示，就是7个字节。也可以用一个字节来表示，用0和1代表是和否。用1个字节替代7个字节来表示信息，空间节省80%以上，更别说是int等其他类型了：

![](https://pic2.zhimg.com/80/v2-3e69076c630fbc54864626ba419762a9_1440w.webp)

需要解决如下几个问题：

> 怎么读取某个位是0还是1？

以第三位为例，即4的二进制00000100，利用与运算，可以值到某个位是否被置起来：

```js
  00001001//9的二进制
& 00000100//4的二进制
= 00000000//0的二进制

即 00001001 & 00000100 != 00000100 可判定，第三位没有被置起
  00001101//13的二进制
& 00000100//4的二进制
= 00000100//4的二进制
即 00001101 & 00000100 == 00000100 可判定，第三位被置起了
```

> 怎么在不影响其他位的情况下，把某个位设为1？  

这里会利用到或运算，我们还是以第三位为例子：

```js
//当第三位没有被置起时
  00001001//9的二进制
| 00000100//4的二进制
= 00001101//13的二进制
//当第三位被置起时，设置前后，值应该是不变的
  00001101//13的二进制
| 00000100//4的二进制
= 00001101//13的二进制
```

> 怎么在不影响其他位的情况下，把某个位设为0？

这里会利用与、取反运算，我们仍以第三位为例子： 4的二进制00000100取反得到11111011

```js
//当第三位没有被置起时
  00001101//13的二进制
& 11111011//4的二进制取反
= 00001001
```

综上所述，最后将上面过程实现为如下java：

```java
class BitUtil{
    public static boolean check(int flag, int bit){
        return (flag & bit) == bit;
    }
    public static int setBit(int flag, int bit, boolean value){
        if(value){
            return flag | bit;
        }else{
            return flag & (~bit);
        }
    }
}
```













## **概念篇**

**and 操作，操作符“&”**

10012���1101210012  
**定义：**称为按位与运算符。它对整型参数的每一个二进制位进行**布尔与**操作，即两个对应的二进制位同时为1时，才等于1。

  

**or 操作，操作符“|”**

10012��1101211012

**定义：**称为按位或运算符。它对整型参数的每一个二进制位进行**布尔或**操作，即两个对应的二进制位，任意一个为1时，就等于1。

  

**xor操作，操作符“^”**

10012���1101201002

**定义：**称为按位异或运算符。它对整型参数的每一个二进制位进行**布尔异或**操作，即两个对应的二进制位，有且仅有一个为1时，才等于1。

  

**not操作，操作符“~”**

���1101200102

**定义：**称为按位非运算符。它是一个单运算符，对运算数的所有二进制位进行取反操作。

  

**shl操作，操作符“<<”**

11012≪1110102

**定义：**称为按位左移运算符。它把第一个运算数的所有二进制位向左移动第二个运算数指定的位数，而新的二进制位补0。将一个数向左移动N个二进制位相当于将该数乘以2的N次方，比如： 11≪1=22 ， −5≪2=−20

  

**shr操作，操作符“>>”**

11012≫11102

**定义：**称为按位右移运算符。它把第一个运算数的所有二进制位向右移动第二个运算数指定的位数。为了保持运算结果的符号不变，左边二进制位补 0 或 1 取决于原参数的符号位。如果第一个运算数是正的，运算结果最高位补 0；如果第一个运算数是负的，运算结果最高位补 1。将一个数向右移动N个二进制位相当于将该数除以2的N次方，比如：

11≫1=5 ， −11≫1=−6 ， −15≫2=−4 （总是向负无穷方向取整）。

---

## **原理篇**

**进制转换**

进制之间的转换其实是个数学问题，在实际应用中，我们基本上无需操心。因此这里想说的不是计算问题，而是逻辑问题。二进制与十六进制有着天然的联系——每四个二进制位可以代表一个十六进制位：

十进制二进制十六进制十进制二进制十六进制11000012116101010102�16151011112�1631100001 111121�16175101010 11112��16255101111 11112��16

由上图可见，如果说二进制转十进制还要稍稍心算一下的话，那二进制转十六制可以马上得出。只要记住了一个十六进制位与四个二进制位的对应关系就好了。同理，八进制位与二进制的关系是，每三个二进制位对应一个八进制位，但实践中，八进制并不常见，因此点到即止。

那么，为什么二进制与十六进制在实践中更常见呢？这是与内存的储存单位有关。

  

**字节与二进制数的关系**

对于计算机而言，最小的储存单位是一个字节，英文为byte。byte既是一个单位，也是一种数据类型（关于数据类型的解释，可查阅C/C++、JAVA等静态类语言的相关资料，本文不作介绍）。对于一个byte的数据，用了八个二进制位去储存数据，因此能正好用两个十六进制位来省略表示（比十进制还少写一位）。这就是为什么在实际操作中，二进制与十六进制更常见的原因。

  

**二进制运算符的操作范围**

笔者查阅了许多二进制运算的相关资料，似乎都忽略了对这一点的介绍。二进制运算符的作用范围与参与运算的变量的数据类型有关，比如以JAVA为例：

- 对于byte类型变量，由于byte以8-bit（8个二进制位）表示，因此相应的位运算符的作用范围就是8-bit；
- 对于int类型变量，由于int以32-bit表示，因此位运算符的作用范围就是32-bit；
- 假如两个大小不一的数据类型进行操作，那位运算的作用范围会以较大的数据类型作为基准范围。

  

**二进制数的符号**

有了数据类型的范围限定，因此才有了高位、低位、符号位的概念。

- 高位，指在数据类型限定范围内靠左的二进制位；
- 低位，指在数据类型限定范围内靠右的二进制位；
- 符号位，指在数据类型限定范围内最左边的一个二进制位，符号位为0表示正数，1表示负数。（除了C语言存在无符号的值类型外，绝大部分语言的值类型都默认为有符号的数值类型）

因此，假如一个byte范围内的整数，提升为一个int范围内的整数，由于二进制位数的范围大了，必然需要进行补位，因此：

- 当原byte整数为正数时，提升为int类型时，补位全部以0补位；
- 当原byte整数为负数时，提升为int类型时，补位全部以1补位；

为什么要这样做？因为这样才能保证数值在范围提升后，原值的十进制数不变。以下来看看JAVA的验证代码：

```java
// byte类型的值范围是[-128,127]
byte a = (byte) -55; //由于值在byte范围内，因此强制转换缩小变量内存范围不会改变原值
byte b = (byte) 100;

System.out.println(Integer.toBinaryString(a)); //输出（二进制数）：11111111111111111111111111001001
System.out.println(Integer.valueOf(a)); //输出：-55（重新提升范围，值不变）
System.out.println(Integer.toBinaryString(b)); //输出（二进制数）：1100100（高位的0会被省略显示）
System.out.println(Integer.valueOf(b)); //输出：100
```

  

**二进制下的负数表示法**

对于一个十进制的负数，我们经常把它看作是一个数加一个负号；然而对于二进制负数来讲，却不是一堆二进制位数加一个符号位。

二进制的正数与负数之间的关系更像是“进位”的关系。以下我们以一个byte值来举例：  
如上所述，byte的数值范围是[-128,127]。

十进制二进制十进制二进制127100 111 11112126100 111 11102……1100 000 000120100 000 00002−1101 111 11112−2101 111 11102−3101 111 11012……−127101 000 00012−128101 000 00002

为了让表示更清楚，笔者特意把符号位隔开。留意从0到-1，由于非符号位全部为0，已经没有东西可减，但假如我们假设从更高的位借来了一个1，这样就能让 0−1=−1 了；有了-1，那 −1−1=−2 就可以继续成立了……直到把除符号位之外的位全部减完，这时十进制数就相当于-128。因此，八位二进制数可以表达的数为 28=256 个，即[-128,127]。

  

**二进制数的性质**

由以上的二进制数变化规律，我们可以发现二进制数有以下性质：

- ～x = -x - 1：从以上0与-1的按位关系可以看到，两者的二进制位正好取反；此规律能推广到1与-2，2与-3……等等。因此，该性质是not操作中最常使用的性质。
- (~x)&x = 0：任意数与它的取反数的and操作结果为0。
- (~x)|x = -1：任意数与它的取反数的or操作结果为-1。
- (~x)^x = -1：任意数与它的取反数的xor操作结果为-1。
- x|0 = x：任意数x与0的or操作结果为x自己。
- x^0 = x：任意数x与0的xor操作结果为x自己。
- x^y^y = x：任意数x与任意数y进行两次xor操作结果为x自己。

---

与四则运算一样，位运算也有它自己的定律。因此，我们有必要先熟悉并证明一下这些定律。

## **定律篇**

**and操作**

交换律，a&b = b&a  
证明：略（因为显然易见）

结合律，(a&b)&c = a&(b&c)  
证明：只要证明一个二进制位，便能推广到N个二进制位。  
(1&0)&0 = 1&(0&0) = 0；  
1&1&0 = 1&(1&0) = 0。

  

**or操作**

交换律，a|b = b|a  
证明：略

结合律，(a|b)|c = a|(b|c)  
证明：只要证明一个二进制位，便能推广到N个二进制位。  
(1|0)|0 = 1|(0|0) = 1；  
1|1|0 = 1|(1|0) = 1。

  

**xor操作**

交换律，a^b = b^a  
证明：略

结合律，(a^b)^c = a^(b^c)  
证明：

![](https://pic1.zhimg.com/v2-8529c0f999f6ebe886e20b3835ab86b0_r.jpg)

  

**not操作**

结合律，a = ~(~a)  
证明：略

  

**shl操作**

无

  

**shr操作**

无



![[二进制运算 2024-01-13 08.57.51.excalidraw]]
举例：\\
$$
\begin{align}
0110101 = 2^5 + 2^4 + 2^2 + 2^0 \\
x = 2^a+2^b+2^c+2^d+...+2^0*(1||0) \\
x/2 = 2^{a-1}+2^{b-1}+2^{c-1}+2^{d-1}+...+2^0*(1||0)\\
(0110101 - 1)/2 = 2^4 + 2^3 + 2^1 = 0110101/2
\end{align}
$$
