
# 快速排序

1. 每一轮排序选择一个基准点(pivot) 进行分区

  1. 让小于基准点的元素的进入一个分区，大于基准点的元素的进入另一个分区
  2. 当分区完成时，基准点元素的位置就是其最终位置

2. 在子分区内重复以上过程，直至子分区元素个数少于等于1，这体现的是分而治之的思想(divide
   and-conquer)


# 实现方式

## 单边循环快排 (lomuto洛穆托分区方案)

- 选择最右元素作为基准点元素N

- j 指针负责找到比基准点小的元素，一旦找到则与 i 进行交换

- i 指针维护小于基准点元素的边界，也是每次交换的目标索引

- 最后基准点与i交换，i即为分区位置

```java
public static void quick(int[] a, int l, int h) {
  if (l >= h) {
    return
  }
  partition(a, l, h);
  quick(a, l, p-1);
  quick(a, p+1, h);
}

/**
 * @param a 需要排序的数组
 * @param l 分区左边界
 * @parma h 分区右边界
 *
 */
public static int partition(int[] a, int l, int h) {
  int i = l;
  int pv = a[h];
  for(int j = l;j<h;j++) {
    if (a[j]<a[pv]) {
      swap(a, i, j)
    }
  }
}

public static void swap(int[] a, int l, int h) {
  if (l == h) {
    return
  }
  int t = a[l];
  a[l]= a[h];
  a[h] = t;
}
```

## 双边循环快排 (并不完全等价于霍尔分区方案)

选择最左元素作为基准点元素

 - i 指针负责从右向左找比基准点小的元素，i 指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至 i，j 相交最后基准点与i(此时i与i相等) 交换，i 即为分区位置

```java
public static int partition(int[] a, int l, int h) {
  int pv = a[l];
  int i = l;
  int j = h;
  while(i < j) {
    // j从右边找小的
    while(i<j && a[j] > pv) {
      j--;
    }
    // i从左边找大的
    while(i<j && a[i] <= pv) {
      i++;
    }
    swap(a, i, l);
    System.out.println(Arrays.toString(a));
  }
  return i;
}
```
### 双边循环的几个要点

- 基准点在左边，并且要先j后i

- while(**i<j** && a\[j\]>pv) j--

- while(**i<j** && a\[i\] <=pv) i--

## 快速排序-特点

- 平均时间复杂度O($\log_2{n}$)，最坏情况复杂度O($n^2$)
- 数据量比较大时，优势明显，
- 属于不稳定排序。


先选一个基准点, 就是在你现有的元素里选一个元素, 
作为这个基准点元素, 然后分区的规则, 就是把比基准点小的元素放入它的左边分区, 
比基准点大的元素呢放入这个基准点, 右边的顺序, 这样说呢可能不是特别形象, 我们来看右边的演示, 
比如说呢我现在是一个无序的数组对吧, 那我要对它分区
先选一个基准点, 那这个基准点选谁呢, 其实你可以认为是随意选啊, 
比如说我们就选这个四作为基准点, 选完四作为基准点以后呢,
将来呢我就要把比四小的, 也就是123放在四的左边, 
第四大的5785798放在它的右边, 可以吧, 那我们就先忽略这个分区的过程, 
我们先看结果, 当分区成功以后啊, 大家可以看到比四小的321在他左边, 
比四大的9875是不是在它的右边, 而且呢你们会发现啊, 如果这个分区成功了,
那基准点元素它所在的位置, 已经是它最终正确的位置, 大家想是不是这样啊,
因为比四小的在它左边嘛, 比四大的在他右边, 所以四它已经位置已经固定下来了, 
好那这是一一轮分区操作啊, 它能达到的一个效果, 那一轮分区操作大家理解了, 
那接下来无非就是重复这个过程呗, 
你可以把四左边的分区重复刚才的算法,
四右边的分区呢也重复刚才的算法啊, 
这样不断的去递归, 那么我们就可以得到一个有序的结果,
那比如说吧我们再看四左边这个分区啊, 四左边那个分区里, 
假设这回我选一作为这个基准点, 可以吧, 那这个一比一小的将来要排在它的左边啊, 现在没有比一小的, 那也没关系, 也就是它左边不排元素呗, 那比大的二三要排在一的右边, 那我们经过这一轮分区之后, 你会发现它就会变成这个样子, 唉比一大的二三在它的右边, 可以看到这个分区是不是范围又小了啊, 又画出来啊, 一右边的这两个元素组成的一个分区, 那我们再对这个分区内的元素再进行重复的, 这个算法是不是就可以了, 那什么时候算是头呢, 唉大家可以想到啊, 当我分区中的元素个数小于等于一的时候, 也就这个分区里没元素了, 或者是元素个数是一了, 那就说明它的这个最终已经是达到了, 一个有趣的结果, 好那这就是快速排序它的一个描述啊, 那快速排序它不断去在此分区内, 重复这个分区过程, 那么体现的是一种分而治之的思想啊, 这个思想呢它的英文叫divide and conquer啊, 简称叫d and c啊, 所以大家以后看到d and c的缩写, 一定要知道它的含义是分而治之好, 关于这个快速排序的算法描述, 我们就先说到这儿啊, 那下节课呢我们看一下不同的这种分区实现
