在电商场景中秒杀场景是一个非常常见的 比如说我们的双11 618大促等等,就是我们一般的电商软件,像淘宝拼多多等等 在业务上面我们要去下单 实际上是分为两步 对不对 第一步是创建订单锁定的库存 然后呢订单的状态变更为我们的待支付 然后第二步才是我们的支付操作 那么我们下单支付前呢是锁定的库存 那么它能够保证比较好的用户体验 但是它可能会导致我们的库存呢 它一直处于一个锁定的状态 那么我可能不需要了 但是呢我又不去点我们的付款按钮 而一些真正的有需要的用户呢 他们却买不到 所以在业务上面呢 它会有一个订单未支付的状态 达到了一定的时间之后 就会自动关闭订单 然后把这个库存呢释放出来
那我们从技术的角度去考虑 我们有哪些解决方案可以支撑我们这个业务呢 实际上方案有很多啊 比如说我们单机版的有较好的**延迟队列** **时钟轮**等等 但是在现在的企业里面 单机部署的应用实际上是很少的 

在我们**分布式环境**里面 我们能够用的有哪些处理方案 
## 扫表轮询
直接去开一个定时任务去扫描我们的一个订单表,获取我们带支付状态的一些数据 然后判断把一些超时的数据,直接去批量修改状态就可以
这种方案虽然实现起来很简单 但是缺点也是很明显的 首先第一个 如果说我们表中的数据有几百万上千万 那么大量的一个数据集 它的一个查询和修改的压力是非常大的 那么对我们服务器的一个内存消耗量也很大 io也有可能会成为我们系统的一个瓶颈啊 而且也不是很好的控制 那么随着我们定时任务的一个增多和一个细化 那么每个业务他都要对订单去进行一个重复扫描 它可能会导致我们很多查询啊 实际上都是浪费的 在一些比较小的项目里面 我们去用这种方案呢是没有问题 ok的 但是也仅限于比较小的项目好 

## 懒删除 
懒删除以后理解这个思想在很多地方都有运用 比如说我们`Redis`处理过期key的时候 他也有用到这个思想 就是当我们每次用户去查询他自己订单的时候 我们在这个方法里面 可以去给我们订单做一个状态的判断 如果说有订单处于超时状态 我们就直接去进行关闭订单 这种方案实现起来也是非常的简单 而且对我们业务本身的影响也比较小 在查询数据的时候 我们一般通过异步的方式去处理订单校验 那么也不会去影响我们的一个查询性能啊 并且也不需要去依赖 我们外部的一个中间件去处理 只需要呢就在我们业务逻辑里面 做一些简单的数据就ok了 当然这种方案也不是[`银弹`](../附录.md#银弹),它也会存在一定的缺陷 如果说我们用户一直没有去触发这个查询操作 那么我订单是不是会被一直挂起,那么也就没有支付 也没有取消 但是我库存是不是依旧站着了 如果说在业务上 这种延迟处理方案不能够接受的话 那么他就用不了了 好
## 消息队列
消息队列也是业内用的比较多的一种主流方案,我们每次下单的时候 往延迟队列里面去存就ok了 然后我们去设置一个过期时间 那么此时消息队列服务端呢 它不会马上投递给我们的消费者 而是说根据我们消息中的一个属性 延迟达到了我们设置的一个时间之后 他才会去投递给消费者 像我们rock mq呢 它本身就支持这种模式的 可以直接使用 而像ruby mq和卡夫卡来 他需要去做一些额外的操作才能够去实现

这种方案的优点有很多 我们可以随时从队列里面去移除 我们需要实时取消的一些订单 他能够及时的把库存资源腾出来,然后呢我们也可以把消息存在m q里面 他不会去占用我们应用服务器的一个资源啊 还能够实现一个异步化的处理 当我们系统的处理能力不足的时候 那么我们客户端还能够很方便的去进行一个 扩容操作好 
## redis实现 
redis实现主要是通过我们redis中的过期监听的一个机制 那么它是可以在配置文件里面去选择性开启的当我们开启了这个机制之后 那我们在客户端呢实际上是可以去做一个监听 回调 然后再去处理关闭订单的业务逻辑啊 这种方案优点也很多 应用服务器和我们外部的redis 它实际上是一个分离的 那么应用的宕机它不会对redis产生影响 那么集群的扩展呢也非常方便 而且redis超时机制的一个时间 准确度也是非常的高 况且我们很多应用本身都已经引入了redis,我们就可以直接去使用 我们不像消息队列那样要去引入一个中间件 但是我们订单量过大的话 我们每一单都要存在release的一个内存里面 它是比较消耗我们redis服务器资源 
