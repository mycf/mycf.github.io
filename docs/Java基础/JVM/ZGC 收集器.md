

# 垃圾收集过程
大概分为 4 个阶段：并发标记；并发预备重分配；并发重分配；并发重映射。

并发标记(Concurrent Mark)：与 G1一样，**并发标记是遍历对象图做可达性分析的阶段**。前后也要经过类似 G1 的初始标记、最终标记(尽管 ZGC 的名字不叫这些)的短暂停顿。与 G1不同的是，ZGC 的标记是在指针上而不是在对象上进行的。标记阶段会更新颜色指针的 M0/M1 标志位。

并发预备重分配(Concurrent Prepare for Relocate)：这个阶段根据特定的查询条件统计出本次收集过程要清理哪些Region，将这些 Region 组成重分配集(Relocation Set)。重分配集与 G1收集器的回收集(Collection Set)还是有区别的，ZGC 划分 Region 的目的并非为了像 G1 那样做收益优先的增量回收。相反，ZGC 每次回收都会扫描所有的
Region.

并发重分配(Concurrent Relocate)：该阶段是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的每个 Region 维护一个转发表(Forward Table)，记录从旧对象到新对象的转向关系。得益于颜色指针的支持，ZGC 收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将被 读屏障 所截获，然后立即根据Region 上的转发表记录将访问转发到新复制的对象上。并同时修正更新该引用的值，使其直接指向新对象，ZGC 的这种行为称作**指针的"自愈”能力**。

并发重映射(Concurrent Remap)：该阶段所做的主要是修正整个堆中指向重分配集中旧对象的所有引用。但是 ZGC 的并发重映射并不是一个必须要"迫切"去完成的任务。因为即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。因此， ZGC 很巧妙的将并发重映射阶段要做的工作，合并到了下一次GC中的并发标记阶段里去完成，反正它们都是要遍历对象，这样就节省了一次遍历的开销。一旦所有的指针被修正之后，原来记录新旧关系的转发表就可以释放掉了。