这是`JDK动态代理`本身的机制来决定的。

JDK动态代理是通过`Proxy.newProxyInstance()`这个方法来实现的，它需要传入被动态代理的接口，JDK动态代理生成代理类`$Proxy0`会去继承`java.lang.reflect.Proxy`类，同时还会去实现被代理类的接口。

在java是不支持多继承的，而每个动态代理类都继承了`Proxy`，所以JDK动态代理只能代理接口，而不能代理实现类。

Proxy类保存了动态代理的处理器`InvocationHandler`，如果抽出来直接设置到`$Proxy0`动态代理类里面也是可以的，那么就可以针对实现类来做动态代理了。

# 为什么这么设计，

第一个是动态代理的使用场景或者需求，是对原始实现的拦截，然后去做一些功能的增强或者扩展，而实际的开发模式都是基于面向接口来开发的，所以基于接口来实现动态代理，从需求和场景都是吻合的，当然也会存在非接口类需要动态代理，那么JDK动态代理是无法满足的。

第二个在java里面类的继承关系的设计，更多的是考虑到共性能力的抽象，从而提高代码的重用性和扩展性，而动态代理封装了动态代理类的深层的抽象逻辑，以及判断一个类是否是动态代理类，以及`InvocationHandler`的持有等等，把这些抽象的公共逻辑，放在`Proxy`这个父类里面，是正常的设计思路。

所以总的来说，技术方案的设计，是解决特定的场景问题的，如果要去针对普通类来去做动态代理，我们可以选择`Cglib`，它会动态生成被代理类的子类，子类重写父类的所有非`final`修饰的方法，在子类中去拦截父类的所有方法的调用，从而去实现动态代理。


