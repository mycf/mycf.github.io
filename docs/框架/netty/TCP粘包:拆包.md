TCP是个”流”协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，它们是连成一片的，其间并没有分界线。TCP底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况。
（1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；
（2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；
（3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；
（4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。

如果此时服务端TCP接收滑窗非常小，而数据包D1和D2比较大，很有可能会发生第5种可能，即服务端分多次才能将D1和D2包接收完全，期间发生多次拆包。

## TCP粘包/拆包发生的原因

问题产生的原因有三个，分别如下。
（1）应用程序write写入的字节大小大于套接口发送缓冲区大小；
（2）进行MSS大小的TCP分段；
（3）以太网帧的payload大于MTU进行IP分片。


粘包问题的解决策略

TCP以流的方式进行数据传输，上层的应用协议为了对消息进行区分，往往采用如下4种方式。

（1）消息长度固定，累计读取到长度总和为定长LEN的报文后，就认为读取到了一个完整的消息；将计数器置位，重新开始读取下一个数据报；
（2）将回车换行符作为消息结束符，例如FTP协议，这种方式在文本协议中应用比较广泛；
（3）将特殊的分隔符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符；
（4）通过在消息头中定义长度字段来标识消息的总长度。


◎ LineBasedFrameDecoder 换行符
◎ DelimiterBasedFrameDecoder 分隔符
◎ FixedLengthFrameDecoder 固定长度

序列化框架
## Serialzable

## json

## gson

## hessian2



## Protobuf
全称Google Protocol Buffers，它由谷歌开源而来，在谷歌内部久经考验。它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。它的特点如下。

◎ 结构化数据存储格式（XML，JSON等）；
◎ 高效的编解码性能；◎ 语言无关、平台无关、扩展性好；
◎ 官方支持Java、C++和Python三种语言。

## Thrift

Facebook开源

在多种不同的语言之间通信，Thrift可以作为高性能的通信中间件使用，它支持数据（对象）序列化和多种类型的RPC服务。Thrift适用于静态的数据交换，需要先确定好它的数据结构，当数据结构发生变化时，必须重新编辑IDL文件，生成代码和编译，这一点跟其他IDL工具相比可以视为是Thrift的弱项。Thrift适用于搭建大型数据交换及存储的通用工具，对于大型系统中的内部数据传输，相对于JSON和XML在性能和传输大小上都有明显的优势。

## MessagePack


MessagePack是一个高效的二进制序列化框架，它像JSON一样支持不同语言间的数据交换，但是它的性能更快，序列化之后的码流也更小。



