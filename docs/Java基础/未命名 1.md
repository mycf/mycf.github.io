redis hot key遇到过么？怎么处理？
注册 中心是什么？简单介绍一下？如果让你设计一个注册中心，怎么设计？
java内存问题现网排查过么？
log4j的漏洞还记得是什么原理?
二面

JDK 1.7->1.8有什么变化
hashmap Put底层原理
collections stream语法糖
高德地图（二面挂）
一面

ES GEO查询底层原理是什么？
ES Bulk Request为什么比普通Request快
多线程 任务队列如何分配线程
ES是准实时的吗？
leetcode322 （力扣原题，题目编号：322）

二面

spark架构是什么？
spark和mapreduce的区别有哪些？
leetcode19

滴滴（一面挂）
一面

cpu利用率/cpu负载
mysql为啥不用红黑树/java hashmap为啥不用B+tree
事务，a函数调用b函数，如果超时，应该如何处理
kafka零拷贝
kafka会丢数据么？
es分词流程
spark比mapreduce为什么快
什么是rdd
连接池是什么
leetcode151
字节（offer）
一面

动态链接是什么
虚拟地址/物理地址
http 1.1和2.0的区别
google protobuf了解么？还有其他什么序列化的工具用过？swag?
redis时遇到big key hot key？
kafka流量暴增，消息堆积？该怎么做？
spark是实时的么？了解过flink嘛？
vim快捷键
leetcode42

二面

redis分布式锁
violatile 内存屏障
CLH是什么
手撕代码：字符串相关的原题，比较简单

三面

接口高并发的话 会怎么办？
智商题：两个人在圆上下棋，如何先手获得优势？

leetcode15

美团（排序挂）
一面

es脑裂
es 查页api from /to
秒杀系统设计
leetcode103

二面

jvm内存分布
基础类型？包装类型？
基础类型为什么内存小？
重写equal 和 hashcode?
指令重排序？
跳表 多线程加锁？
跳表 构造时间复杂度？
跳表高度很高 还是O(n)
多线程aop记录耗时
多线程传递threadlocal
protobuf用过么？
微服务熔断是什么？
kafka会丢消息？
分布式事务是什么？
kafka消息有顺序么？
dirty read/ 幻读？
disirkta时间复杂度
leetcode347

阿里(offer)
一面

设计模式？工厂模式用过么？
连接池？
mysql查询过程？
b+树是什么？有什么优势？
kafka源码 是怎么快速接收消息？快速发送消息
redis连接 微服务超时了，应该怎么做？leetcode78
二面

系统paging是什么？leetcode340

内存对用户来说就是一段字节数组，根据地址访问某个字节或者某些字节。早期的计算机只有单个程序，内存中除了操作系统的部分，都可以分配给程序使用，后来计算机上为了运行多个程序，这些程序共享一个内存条的不同部分，对内存空间进行了划分。但是这样的问题在于，当前程序所使用的内存空间可能会被其他的进程有意无意的使用，既有安全问题，对于程序便携人员也很麻烦。后来为了解决用户所面临的问题，直接让操作系统解决内存的分配问题。结果就是对于用户而言，每个程序都感觉到自己拥有一个非常大的字节数组也就是内存，可以在该字节数组上任意操作，而这个字节数组就被称为虚拟内存，由操作系统完成虚拟内存到真实内存的地址之间的映射。但是实际情况是，程序越来越多，并且有的程序自己都需要很大的内存空间。所以操作系统将磁盘也用作程序虚拟内存使用，完成由虚拟内存到物理内存地址或者磁盘地址之间的映射工作，这样可以提供的虚拟内存地址空间就很大了。对于用户程序很久都用不到的内存空间由操作系统放在磁盘上存储，需要的时候由操作系统从磁盘上加载到真实内存中。

使用页表实现虚拟内存和物理内存数据页映射的的办法，页表存放着各个虚拟页的状态，该页是否可以直接映射，存放在物理内存等，通过页表中的虚拟页号可以找到对应的物理页号，然后再根据偏移量定位到真实数据存储的物理地址。

当一个进程视图访问虚拟地址空间的数据时：CPU想要访问某个虚拟内存地址，进程会找到页表中的条目，判断有效位是否有效，如果有效说明，数据在物理内存，可以直接访问物理内存地址中的数据。如果无效，则会发生缺页中断，去磁盘中拷贝数据页到物理内存，并更新页表。


长轮询（Long Polling）和长连接（Long Connection）是两种用于实现实时通信的不同技术。

1. 长轮询（Long Polling）：
   - 工作原理：客户端发送一个请求到服务器，服务器接收到请求后不立即响应，而是将请求挂起（保持连接打开）等待有新数据时再返回响应。当服务器有新数据可返回时，响应会立即返回给客户端，客户端再次发起新的请求。这个过程会一直重复，保持了一个长时间的连接。
   - 特点：
     - 服务器可以在有新数据时立即将其推送给客户端，实现实时更新。
     - 客户端需要不断发送轮询请求，这可能会产生较高的请求频率和额外的网络开销。
     - 客户端和服务器之间的连接在每次请求结束后都会关闭，需要重新建立连接。
     - 可以在各种网络环境下工作，包括浏览器和移动设备上的Web应用。

2. 长连接（Long Connection）：
   - 工作原理：客户端和服务器之间建立一次连接后保持长时间的连接状态，不会立即关闭连接。通过这个长连接，双方可以实时地进行双向通信，服务器可以主动推送数据给客户端，而不需要等待客户端的请求。
   - 特点：
     - 服务器可以主动推送数据给客户端，实现实时通信，避免了客户端不断发起请求的开销。
     - 保持长连接可能会占用服务器资源和网络资源，尤其在大规模的并发连接情况下。
     - 长连接通常需要应用层协议的支持，例如WebSocket等。
     - 在浏览器中，长连接需要使用特定的技术（如WebSocket）来实现。

总的来说，长轮询适用于需要实时更新但请求频率不是特别高的场景，而长连接适用于双向实时通信且请求频率较高的场景。两者的选择取决于具体的应用需求和技术支持。


1. Redis 基于队列串行的文件事件处理机制：
Redis 使用一个事件驱动模型来处理客户端的请求。这个模型中，Redis 服务器使用一个文件事件处理器（file event handler），这是一个单线程的、基于消息队列的机制，负责接收网络请求和数据、执行命令、发送响应。它主要包括两种类型的文件事件：可读事件和可写事件。当有新的网络连接或数据到达时，可读事件被触发；当需要向客户端发送数据时，可写事件被触发。通过这种方式，Redis 能有效地序列化操作，避免了多线程并发处理中的锁和竞争状态问题。

2. Redis 串行化的单线程模型为何能高并发：
虽然 Redis 使用单线程模型处理命令，但它依然能够支持高并发处理，主要原因是大多数 Redis 操作都是内存操作，这些操作非常快，延迟很低。Redis 内部使用非阻塞数据结构和算法，确保单线程能够高效利用 CPU 资源，处理数以万计的并发连接和请求。

3. Redis 节点间的三次握手过程：
在 Redis 中，节点间三次握手通常是指 Redis 集群中的节点为了确保网络连接的可靠性，参考 TCP 协议的三次握手过程建立连接。首先，客户端发送一个 SYN 包到服务器，并进入 SYN_SEND 状态；服务器收到后回送一个带有 SYN/ACK 的确认包，以确认客户端的 SYN；客户端收到后，再发送一个 ACK 包给服务器，完成连接的建立。

4. Redis 基于 slots 槽位机制的数据分片原理：
Redis 集群通过将所有的数据分散存储到不同的节点上来实现扩展性。这是通过将所有的键分配到 16384 个哈希槽中来实现的。每个节点负责一部分哈希槽，当需要访问一个键时，Redis 使用 CRC16 算法计算键的哈希值，然后对 16384 取模来确定应该将键分配到哪个槽，进而确定对应的处理节点。

5. Redis 集群扩容时，slots 转移过程：
当 Redis 集群进行扩容或收缩时，需要进行槽位迁移以重新平衡各个节点的负载。这个过程通常涉及到将一部分槽及其包含的键从一个节点迁移到另一个节点。这是通过 CLUSTER SETSLOT 命令来手动指定某个槽应该由哪个节点来处理。在迁移过程中，涉及的节点会协调来确保数据的一致性和完整性。

6. Redis SYNC 主从复制的过程及其缺陷：
Redis 的主从复制开始时，从节点会发送一个 SYNC 命令给主节点。主节点收到后会开始一个 BGSAVE 进程，把当前的数据库状态保存到磁盘上，并将此时的写命令缓存起来。完成后，主节点将保存的数据库文件发送给从节点，从节点载入这个文件，并应用缓存的写命令。这个过程的缺陷是它可能在数据量大时消耗较多的网络带宽和磁盘 I/O。此外，如果连接中断，整个同步过程可能需要重新开始。为了改善这一点，Redis 后来引入了部分重同步机制，即 PSYNC。

7. Redis 主节点选举算法以及故障转移机制：
Redis 使用 Raft 等一致性算法来实现主节点的选举和故障转移。在 Redis 集群中，主节点故障时，从节点会发现主节点失联，并发起选举，选出一个新的主节点。这个过程中，集群中的其他节点会投票，通常是根据投票数最多的节点被选为新的主节点。然后，集群中的其他从节点会开始复制新主节点的数据，从而完成故障转移，保证集群的可用性。