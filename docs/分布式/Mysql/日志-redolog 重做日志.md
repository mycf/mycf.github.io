> [!NOTE] 为什么不在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘？
> 1. 刷新一个完整的数据页太浪费了
> 2. 随机IO刷起来比较慢

# 作用
记录了对于==InnoDB存储引擎的事务日志==。如果数据库发生宕机了，Innodb存储引擎可以通过redolog恢复之前的状态，从而保证数据完整性。

重做日志用来实现事务的==**持久性**==，即事务ACID中的D。其由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），其是持久的。

写入重做日志文件的操作不是直接写，而是先写入一个重做日志缓冲（redo log buffer）中，然后按照一定的条件顺序地写入日志文件。

参数`innodb_flush_log_at_trx_commit`控制重做日志刷新到磁盘的策略。

- `1`：默认值，表示事务提交时==必须调用一次fsync操作。
- `0`：表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，而在master thread中==每1秒会进行一次重做日志文件的fsync操作。
- `2`：表示事务提交时将重做日志写入重做日志文件，但==仅写入文件系统的缓存==中，不进行fsync操作。

由于fsync的效率取决于磁盘的性能，因此磁盘的性能决定了事务提交的性能，也就是数据库的性能。

因此为了*保证事务的ACID中的持久性*，必须将`innodb_flush_log_at_trx_commit`设置为`1`，也就是每当有事务提交时，就必须确保事务都已经写入重做日志文件。那么当数据库因为意外发生宕机时，可以通过重做日志文件恢复，并保证可以恢复已经提交的事务。而将重做日志文件设置为0或2，都有可能发生恢复时部分事务的丢失。不同之处在于，设置为2时，当MySQL数据库发生宕机而操作系统及服务器并没有发生宕机时，由于此时未写入磁盘的事务日志保存在文件系统缓存中，当恢复时同样能保证数据不丢失。

> [!NOTE] redolog和binlog的区别
> 
>首先，重做日志是在InnoDB存储引擎层产生，而二进制日志是在MySQL数据库的上层产生的，并且二进制日志不仅仅针对于InnoDB存储引擎，MySQL数据库中的任何存储引擎对于数据库的更改都会产生二进制日志。
>
> 其次，两种日志==记录的内容形式==不同。MySQL数据库上层的二进制日志是一种逻辑日志，其记录的是对应的SQL语句。而InnoDB存储引擎层面的重做日志是物理格式日志，其记录的是对于每个页的修改。
> 
>  此外，两种日志记录==写入磁盘的时间点不同==，二进制日志只在事务提交完成后进行一次写入。而InnoDB存储引擎的重做日志在事务进行中不断地被写入，这表现为日志并不是随事务提交的顺序进行写入的。

	