实际上spring boot自动配置的核心原理, 就是去理解`@SpringBootApplication`个注解, 这个注解其实是三个注解的组合, 分别是这里的 `@SpringBootConfiguration` 还有`@EnableAutoConfiguration` , 以及`@ComponentScan`, 它实际上的功能就是我们以上三个注解功能的组合

```java
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
```

# `@SpringBootConfiguration`

实际上跟普通的`@Configuration` 是类似的, 可以看到它这个注解上又标注了`@Configuration` 注解, 它的功能就相当于继承了这个`@Configuration`注解, 功能上完全等价。


> [!NOTE] `@SpringBootConfiguration`跟`@Configuration`的区别
`@Configuration`标注的, 将来在一个应用程序里是可以有多个的, 可以有多个配置类, 但是 `@SpringBootConfiguration` 它对应的配置类, 整个应用程序应该只有一个。

# `@ComponentScan`

组件扫描, 可以扫描标注`@Component`、`@Service`、`@Repository`、`@Controller`, 不过这个`@ComponentScan`里加了一个`excludeFilters`, 就是在扫描时加一些过滤器, 这些过滤器是用来扫描做一个排除动作的, 如果匹配到了, 他就会把匹配到的这些类做一个排除。


# `@EnableAutoConfiguration`

是一个组合注解, 它由两部分组成, 一个是`@AutoConfigurationPackage`, 还有一个是`@Import(AutoConfigurationImportSelector.class)` ,  先来看这个`@AutoConfigurationPackage`
![[AutoConfigurationPackage]]

我这提前已经写好了一段测试代码, 好那么大家来看啊, 就是首先我有个my config啊, 这么一个主配置类呀, 这个配置类里啊, 我会去做一个组件扫描啊, 为了缩小这个扫描范围, 我只扫描了我这个day 04 boot sub这个报价啊, 这个报价呢有两个类啊, 有两个病啊, 一个病因, 一个b2 啊, 他们都用component这个标注了, 所以将来应该都是会被扫描到啊, 好那如果我不加任何的这个过滤器啊什么的啊, 它最终应该把b1 b2 都扫描到, 那我这里会去在容器这个准备好以后啊, 去看一下容器内有多少bean的名字, 把所有bean的名字打印出来, 好可以看到除了这些是一些后处理器的啊, 除了后处理器之外, 我们的my config自身以及它扫描到的b1 b2 , 都出现在我们最终的容器中了, 好, 那比如说我现在想在扫描的过程中对一些类啊, 做一些排除, 那排除的话, 那我们就可以加一个特殊的病啊, 就加一个my filter这样一个过滤器病啊, 这个过滤器病呢要实现type exclude filter这个接口, 也就是哎我要做一些排除动作啊, 你必须实现这个接口, 实现完接口以后, 你的内部啊, 就是去通过实现match方法, 来判断这个类到底是该被排除还是该被保留, 那当它的返回值是真的话, 就表示要过滤掉, 就把它排除掉, 当它这个方法返回值是假的话, 就表示要保留, 那我我这个怎么去判断它是真是假的啊, 这个就是我们可以通过他传过来一个参数, 叫metadata reader, 这个呢是在我们在扫描过程中啊, 能拿到的一些原数据啊, 一些原数据, 通过原数据呢, 我们可以得到当前这个类它的各种信息, 包括他类的信息, 他类上加的注解信息等等, 那这里呢我就做一个很简单的过滤啊, 我们通过这个reader呢拿到它的类的信息, 类的原数据, 然后呢可以进一步get class name, 也就是得到它的当前扫描到的这个类的类比二, 那我会把这个类名呢通过日志先打印一下, 然后我的判断规则很简单啊, 如果你的类名是一种病一的话啊, 我们刚才不是有病一并二吗, 是并一的话, 我有return true, 就表示啊b一我不要, 那剩下的我就把它保留return false啊, 也就是我想排除掉b好, 那这个过滤器写好了, 写好以后呢, 我们也要把它注册到容器当中, 但这样能不能工作呢, 其实还不行啊, 因为我们这个过滤器虽然你实现了, 但是你没把它用上, 你可以看到最终还是b1 b2 , 他并没有为这个调用, 也就是他这个match方法并没有用上, 那为了让它生效呢, 好简单啊, 就是我们就模仿人家这个视频, boot application中的这个components, 看你看人家咋用的啊, 它里面就加了一个说排除过滤器是谁呢, 哎后面你跟上这个具体的过滤器就可以了, 当然我们这里啊啊, 不用去把我们的过滤器名字给他, 我们只要仿照人家这个写法

直接拷贝粘贴过来就可以了, 好把这个包找一下, 啊他这个过滤器的作用, 它就是会读取容器中所有实现了这个type exclude, filter接口的啊, 这么样的过滤器啊, 然后呢去调用他们的match方法, 然后根据我们刚才说的这个规则, 返回出的过滤掉, 返回false, 保留好, 我们加上这个exclude future以后啊, 我们再来看, 好可以看到我在每次调用match的时候, 我都会把这个并打印出来啊, 所以最终扫描到的有宾语和宾二, 但是呢最终保留在容器里的只有b2 b一呢, 因为我们return true啊, 就把它过滤掉了, 好, 这就是我们这个component sky里面, 这个exclude filters, 它的一个作用就是去排除某些类, 好, 当然我们看一下人家的写法里, 它还有一个过滤器, 那下面这个过滤器其实跟他差不多, 那下面这个过滤器我只说一下它排出的是什么, 他就是把那些啊它是吧, 你有可能扫描到spring boot的一些包, 你扫描到子分部的包了, 万一你把人家一些自动装配类也扫描到了, 怎么办呢, 哎自动装配类啊, 我们待会儿是要通过这个以内包, auto confusion中使用input的方法来导入的啊, 不是通过组件扫描扫描扫描的, 所以呢我这个组件扫描的时候, 他为了防止你不小心, 这个报名指定了什么spring boot的包, 万一扫描到了一些自动装配自动配置类啊, 这是我不希望看到的, 所以呢接下来这个过滤器呢, 它就是排除掉所有的自动配置类啊, 排除叫spring自己的spring boot, 自己的那些自动配置类好, 那到此为止呢, 我们就把前两个给大家讲完了, 一个是spring boot computation, 他们有什么特殊之处, 它就表示他当前的这个配置类, 然后commander干呢, 这里我们新学了一个, 它可以通过一些过滤器啊, 排除掉, 实现了这个type exclude filter接口的一些这个类, 另外呢, 它还可以把spring boot自身带的一些自动配置类, 进行一个排除, 好这两个注解我们就给大家讲到这儿

我这里啊单独演示一下它的用法, 比如说我现在有一个配置类, 配置类上加了我们刚刚这个auto可能是pad的注解, 那它的作用是什么呢, 它的作用就是它所标注类的报名啊, 会被记录下来, 然后放在容器当中, 将来呢你要用到这个报名的时候, 那我们可以通过一个工具类啊, 到容器里找到这个报名好, 那我们给大家演示一下啊, 现在我这个类已经加好了啊, 这个注解已经加好了, 然后呢呃我的类所在的包是这个day 04点boot, 如果你的程序里将来要真正用到那个报名, 我们就通过一个工具啊, 叫auto configuration package啊, 注意啊, 他俩不一样, 下面不带s不带s的, 这个是注解, 带s的呢, 这个是一个工具类啊, 我们可以通过get方法去获取那个报名, 你需要传给他一个兵工厂, 那我们可以去拿到一个兵工厂, 然后呢他就会把这个报名的一个集合打印出来, 好看一下它的输出是不是day 04 boot day 04步呀, 

所以这就是这个注解的作用, 就是记录它所标注的类所在的包啊, 就干了这么件事, 作用并不是很大啊

好我们继续来看, 啊看一下它这个input的作用, 这个input呢我在讲之前, 我们先来想一个场景啊, 比如说我现在有这样的一个需求, 我有一个这个mac config, 我把它看成是一个主配置, 然后呢我又还有一个叫other config啊, 它是一个从属配置, 这个呢你就可以把它联想成是, spring提供的一个自动配置类, 可以吧, 就是一个带completion的一个配置类吗, 其实我不太愿意翻译成自动配置啊, 我更愿意把它翻译成一个默认配置, 什么意思呢, 就是你主配这里我没配, 哎, 那我就可以用这个默认配置去顶上去对吧, 你不能缺东西吗, 你可以覆盖, 但是你不能缺好, 那现在我的需求是这样, 我的主配置想把从属配置里面这些个信息啊, 都给它加入到此生容器的来, 那怎么做呢, 好那有同学说哎我可以这么做呀, 我们用一个input, 是吧, 然后后面直接跟上我们的other config, 是不是用input, 就把这个存储配置, 以及它里面的这些bean的定义, 都给它加入到了中期来了, 好我们试一下啊, 好我这里会打印容器, 初始化好以后会打印所编的名字, 好可以看到啊, 这样的话我加完input之后啊, other config自身, 包括里面的b1 , b2 都会加入到当前的spring容器当中, 但是这样做好不好呢, 我们可以分析一下啊, 其实有两个缺点, 第一个缺点就是导致我的主配置, 和我的从属配置啊, 他俩是一个紧密耦合了啊, 就是总数配置, 这必须知道从属配置的类名称是不是强耦合呀, 不好最好呢能够把它分开啊, 不要直接引用对方的名字好, 这是第一点, 第二点呢就是咱们之前讲过了, 你input的话, 如果直接引入这个配置类, 那input执行的优先级就比较高, 而通常呢我们希望这个属于这种从属配置, 或者说这种自动配置或者默认配置, 怎么叫它都好, 这种配置我们希望它的优先级是最低的, 等你主配置里面这些什么component sky呀, 主配之中自己的那些艾滋病啊, 全部解析完了, 我最后再去解析我这个从属配置, 用put加进来的, 那怎么实现这两点呢, 唉就是我们auto confusion它里面帮我们做到的啊, 他这个input的后面跟的这个类啊, 它就会实现我们刚刚说的两个需求, 第一个需求啊, 就是它可以分离主配置和存储配置啊, 它不会让主配置直接去知道存储配置的类名, 而是把这些存储配置啊写在一个文件, 将来由后面这个类啊, 有我们这个input stack, 找区配置文件里去找, 到底有哪些存储配置的类型, 这样是不是就实现了这种弱耦合呀, 好这是第一点, 第二点呢我们来看一下这个input select啊, 它是实现了default input select接口, 什么意思啊, 我们刚讲过了, 他就是可以推迟这个input它的解析工作啊, 也就是保证我们主配置类中那些啊, 相应的components cam at并全部解析完了, 最后再来解析这个input, 它所引入的那些从属配置的信息, 好, 那我给大家演示一下啊, 比如说我想达到这个目的, 我就不能这么做了, 我就用我们的input auto computer啊, 因为它内部相当于就间接的用这个input, 会应用后面这个input select, 当然前面这个也可以不要了啊, 因为它上面这两个注解是不是都包含了, 那后面这些exclude name什么意思呢, 就是我想把spring自带的那些自动配置类都排除, 因为我们这个input selector, 他工作的时候, 他会把spring自带啊, spring boot自带的那些自动配置类全部都扫描到, 这个数目比较多, 打印出来不好看, 所以我就给他排除了, 跟你讲啊, 那我们自己写的那个配置类, 自己的这个存储配置类, 我们把它放哪呢啊, 他就要求有一个配置文件, 这个配置文件的位置跟名字都是固定的
必须是在你class pass下一个叫做metadata info, 这个文件夹下, 你要建一个名字叫做spring factories, 这么一个啊文件啊, 它其实就是一个properties, 文件里面呢是一些建筑信息, 其中剑呢是固定的啊, 这个就对应着我们的自动配置的一个键值呢, 就是我们刚才的这个other config, 它的具体的类名, 如果你将来有多个配置了, 你中间用逗号分隔就可以好, 这个配置完了以后, 我们再来运行, 我们的目的啊, 还是找到这个, 还是加载这个other config和里面的并一定二吧, 哎可以看到二个config, 包括里面的b1 b2 是不是都加载进来了, 哎所以目的达到了, 但是好处我们也说了, 首先主配置它并不需要强耦和other这个, 其次呢other config的解析它的优先级是最低的啊, 因为呢我们这个input, 它的对应的select实现是实现了这个differ input, select啊, 保证它的优先级最低, 因此呢它可以被我们主配之中啊, 相同优先级的啊, 相同的这个名字的病啊, 覆盖我们可以给大家演示一下啊, 呃我们加一个这个什么吧, condition啊, 肯定上啊, missing me, 大家看啊, 如果从属配置, 属配置里面没有配置这个定义啊, 那我这个存储配置应该生效做的打印, 这里面我们是打印other complete中的定义, 没问题吧, 哎他最终用的是啊, 主配之中没有的话, 它缺失了这个病啊, 他就是使用的我们这个自动配置中的, 这个定义啊, 但是如果我的主配置中也提供了一个, 相同名称的定, 好这个我们把这改一下, 那么由于主配之中的这个病是先被处理啊, 他的优先级高, 他先被处理, 他先被处理了以后啊, 相当于把这个病已经创建好了, 放到容器里了, 那么我们的auto configuration中带的这个input selector, 他的优先级比较低, 那它后处理other, 那other config处理到我们这个病, 他自己这个病因的时候, 他发现容器里已经不缺失这个病了, 所以这个条件不成立, 也就不会执行里面的内容, 也就是用的我们主配置中的这个病因, 好看一下是不是用的主配这种配并一样, 当然我们剩余的什么并一并二也都会有好, 那这是关于我们这个自动装配的原理啊, 就给大家讲完了, 咱们总结一下吧, 自动装配原理就是要求大家理解这个spring boot application啊, 它又由三个注解组成, 一个呢是spring boot computation, 表示当前这个类是一个配置类, 然后呢, component scan呢, 是可以在这个配置类上进一步做一些组件扫描, 可以用这个exclude filters啊, 在组件扫描的时候做一些排除操作, 同时呢, 它也会把spring boot自带的一些自动配置类, 做一个排除, 最重要的是下面这个叫enable auto confusion, 其中他又有两个注解, 一个呢是auto confusion package啊, 它是用来记住扫描的一个起始包啊, 最后这个最重要就是at import注解啊, 它用来使用了一个input selector, 选择器来导入一些存储配置, 它的特点呢是低一点, 可以分离我们的这个主配置和存储配置, 让它们之间不要有强耦合, 第二点呢, 它的执行优先级比较低啊, 他先保证我们主配之中那些配置啊, 全部加载完了, 最后再来解析从属配置, 也就是这些自动配置类的写配置信息, 那它加载的位置大家要知道啊, 都是他会去读取class pass下一个固定文件夹, 固定文件名中的那些自动配置类好, 关于spring boot的自动配置, 我们就给大家讲到这里
