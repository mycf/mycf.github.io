sleep() 和 wait() 是在编程中用于线程控制的两个方法，它们有以下区别：

1. 线程关联：sleep() 方法是 Thread 类的静态方法，可以直接在任何线程中调用；而 wait() 方法是 Object 类的实例方法，只能在同步代码块或同步方法中使用。

2. 锁的释放：调用 sleep() 方法不会释放持有的锁，线程会继续持有锁并进入阻塞状态；而调用 wait() 方法会释放当前线程持有的锁，并使线程进入等待状态，直到其他线程调用相同对象上的 notify() 或 notifyAll() 方法来唤醒等待的线程。

3. 调用方式：sleep() 方法是直接调用，会使线程暂停指定的时间，然后继续执行；而 wait() 方法需要在同步代码块或同步方法中调用，它会使线程暂停执行，并释放锁，直到被唤醒。

4. 唤醒方式：通过 sleep() 方法暂停的线程会在指定的时间过去后自动唤醒，继续执行；而通过 wait() 方法等待的线程需要等待其他线程调用相同对象上的 notify() 或 notifyAll() 方法来唤醒。

5. 使用场景：sleep() 方法通常用于暂停当前线程的执行一段时间，用于模拟时间延迟或控制线程的执行速度；而 wait() 方法通常用于线程间的协作，用于等待特定条件的满足或等待其他线程的通知。

总的来说，sleep() 是线程的一种暂停方式，不会释放锁，等待一段时间后自动恢复执行；而 wait() 是线程的等待方式，会释放锁，需要通过其他线程的唤醒来继续执行。


Thread.Sleep(0)的作用是==“触发操作系统立刻重新进行一次CPU竞争”。

# **1、来自不同的类**

这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。

sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用了b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。

  
# **2、有没有释放锁(释放资源)**

最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。

sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。

Thread.Sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。

sleep是线程被调用时，占着cpu去睡觉，其他线程不能占用cpu，os认为该线程正在工作，不会让出系统资源，wait是进入等待池等待，让出系统资源，其他线程可以占用cpu，一般wait不会加时间限制，因为如果wait的线程运行资源不够，再出来也没用，要等待其他线程调用notifyall方法唤醒等待池中的所有线程，才会在进入就绪序列等待os分配系统资源，  
sleep是静态方法，是谁掉的谁去睡觉，就算是在main线程里调用了线程b的sleep方法，实际上还是main去睡觉，想让线程b去睡觉要在b的代码中掉sleep  
  
sleep(100L)是占用cpu，线程休眠100毫秒，其他进程不能再占用cpu资源，wait（100L）是进入等待池中等待，交出cpu等系统资源供其他进程使用，在这100毫秒中，该线程可以被其他线程notify，但不同的是其他在等待池中的线程不被notify不会出来，但这个线程在等待100毫秒后会自动进入就绪队列等待系统分配资源，换句话说，sleep（100）在100毫秒后肯定会运行，但wait在100毫秒后还有等待os调用分配资源，所以wait100的停止运行时间是不确定的，但至少是100毫秒。

就是说sleep有时间限制的就像闹钟一样到时候就叫了，而wait是无限期的除非用户主动notify  

  
# **3、使用范围不同**

wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用  
   synchronized(x){  
      x.notify()  
     //或者wait()  
   }

  
# **4、是否需要捕获异常**

sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。