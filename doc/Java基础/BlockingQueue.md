`BlockingQueue`接口是Java集合框架中的一个接口，它是`Queue`接口的子接口，提供了一系列用于实现阻塞队列（Blocking Queue）的方法。阻塞队列是一种特殊的队列，当队列为空时，从队列中获取元素的操作会被阻塞，直到队列中有可用元素；当队列已满时，往队列中添加元素的操作会被阻塞，直到队列有空闲位置。

![[BlockingQueue 2023-12-27 22.33.30.excalidraw|1000]]
当队列是空的，从队列中获取元素的操作将会被阻塞。
当队列是满的，从队列中添加元素的操作将会被阻塞。
试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。
试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。

后进先出( LIFO ): 后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)。
在多线程领域:所谓阻塞，在某些情况下会挂起线程(即阻塞)，一旦条件满足，被挂起的线程又会自动被唤起。

为什么需要 BlockingQueue
好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你 手包办了
在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。
# 常见的BlockingQueue
- [[ArrayBlockingQueue]]：基于数组实现的有界阻塞队列，按照先进先出的原则进行操作。

- [[LinkedBlockingQueue]]
基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着个数据缓冲队列( ==该队列由一个链表构成== )，当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回:只有当队列缓冲区达到最大值缓存容量时 ( LinkedBlockingQueue 可以通过构造函数指定该值)，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。

==一句话总结: 由链表结构组成的有界( 但大小默认值为integer.MAX VALUE)阻塞队列。==

- [[DelayQueue]]
DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作(生产者 )永远不会被阻塞，而只有获取数据的操作(消费者才会被阻塞。
==一句话总结: 使用优先级队列实现的延迟无界阻塞队列。==
- [[PriorityBlockingQuleue]]
基于优先级的阻塞队列(优先级的判断通过构造函数传入的 ***Comparator*** 对象来决定)，但需要注意的是 PriorityBlockingQueue 并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。
因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。
在实现 PriorityBlockingQuleue 时，内部控制线程同步的锁采用的是公平锁。
==一句话总结: 支持优先级排序的无界阻塞队列。==


- [[SynchronousQueue]]
一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节(缓冲区 )，如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些( 可以批量买卖 ) ;但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能降低。

==一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。= =


下面是`BlockingQueue`接口中常用的方法及其作用：

1. `void put(E e)`：
   将元素添加到队列的尾部，如果队列已满，则调用线程会被阻塞，直到队列有空闲位置。

2. `boolean offer(E e, long timeout, TimeUnit unit)`：
   将元素添加到队列的尾部，如果队列已满，则调用线程会被阻塞，直到队列有空闲位置或超过指定的等待时间。

# `E take()`：
   移除并返回队列头部的元素，如果队列为空，则调用线程会被阻塞，直到队列有可用元素。

# 4. `E poll(long timeout, TimeUnit unit)`：
   移除并返回队列头部的元素，如果队列为空，则调用线程会被阻塞，直到队列有可用元素或超过指定的等待时间。

5. `int remainingCapacity()`：
   返回队列的剩余容量，即可以添加到队列中而不被阻塞的元素数量。

6. `boolean remove(Object o)`：
   从队列中移除指定的元素，如果成功移除则返回`true`，否则返回`false`。

`BlockingQueue`接口扩展了`Queue`接口，并添加了一些阻塞操作的方法。这些方法可以在队列已满或队列为空时，进行阻塞等待或超时等待，以实现线程之间的同步和协作。

`BlockingQueue`的实现类有很多，常见的有`ArrayBlockingQueue`、`LinkedBlockingQueue`、`PriorityBlockingQueue`等。不同的实现类具有不同的特性和性能特点，可以根据具体的使用场景选择合适的实现类。