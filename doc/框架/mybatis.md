

# 分页

## limit分页

## **RowBounds分页（不推荐使用）**

## PageHelper分页插件

# 缓存

二级缓存和一级缓存的原理是一样的，第一次查询，会将数据放入缓存中，然后第二次查询则会直接去缓存中取。

但是一级缓存是基于的**sqlSession**，

而二级缓存是基于**mapper文件的namespace**的，

也就是说**多个sqlSession**可以**共享**一个mapper中的二级缓存区域，并且如何两个mapper的namespace相同，即使两个mapper，那这两个mapper中执行sql查询到的数据也将存在相同的二级缓存区域中




# 分布式锁的实现



那分布式锁，其实它是在多台机器之间的一个互斥锁，它是一种跨进程跨机器的这个互斥锁。

什么叫互斥锁，就是我用了你就不能用 又叫做排他锁。所以它是用来去保证我们多机器、多节点之间的一个资源共享访问的一种排他性 所以需要一个分布式锁 

分布式锁它和线程锁都是锁，它本质上是一样的，线程锁的这个生命周期，在这个单进程多线程里面 而分布式锁，它的生命周期是多进程、多机器节点的。

它本质上都要满足几个条件 比如说第一个排他性，也就是说同一时刻只能有一个资源去访问这个共享资源，第二个就是可重入性 就是允许一个已经获得锁的进程，在没有释放锁之前，可以再次去重新获得锁 第三个就是锁的获取以及释放的一个方法，要有一个统一，第四个就是锁的一个失效机制，避免死锁产生。所以只要满足这些特性，都能够去实现这个分布式锁，

 一般来说我们在业界来看，有两种比较常见的方式：

第一种的话就是采用全局表，就是利用关系数据库去使用一个唯一的约束，来实现锁的一个排他性，所以我们就可以去创建一个就是方法 包括方法名称之类的一个字段 并且把这个方法名设置成唯一的一个约束 那么抢占锁的这个逻辑 就是往这个表里面插入一条数据 那如果这个表里面已经有其他线程获取的这个方法的这个锁 那这个时候插入数据就会失败 从而保证了这个互斥性 那么这种方式虽然简单 但是还要实现完整丰富的话 需要考虑一些就是重入、锁失效机制包括没有抢占锁的一些线程，要实现阻塞等等等等 就比较麻烦 

第二种中间件redis，它提供了这个set nx命令 去实现排他性，它的基本的原理就是 当我们的key它不存在就返回一，那么存在就返回零，可以设置它的一个过期时间 从而去避免死锁的一个问题。当然如果过期了，但是业务逻辑还没执行完成，可以写一个定时任务进行续期。有一个redisson组件 它就直接提供了一个分布式锁的一个封装实现 然后他内置了这个watch dog的一个机制 来对锁的key进行一个续期，所以这种方式基本上能解决分布式锁 99%以上的问题



